import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('data_processing/fixture_detection.py', b'import cv2 as cv\nimport numpy as np\nimport random\n\nfrom flags import SHOW_DEBUG\n\nclass Filter:\n    def __init__(self, lower_hsv, upper_hsv):\n        self.lower = np.array(lower_hsv)\n        self.upper = np.array(upper_hsv)\n    \n    def filter(self, img):\n        hsv_image = cv.cvtColor(img, cv.COLOR_BGR2HSV)\n        mask = cv.inRange(hsv_image, self.lower, self.upper)\n        #imgResult = cv.bitwise_and(img, img, mask=mask)\n        return mask\n\n#red_filter = Filter(lower_hsv=(73, 157, 127), upper_hsv=(179, 255, 255))\nred_filter = Filter(lower_hsv=(160, 170, 127), upper_hsv=(170, 255, 255))\n#yellow_filter = Filter(lower_hsv=(0, 157, 82), upper_hsv=(40, 255, 255))\nyellow_filter = Filter(lower_hsv=(25, 157, 82), upper_hsv=(30, 255, 255))\nwhite_filter = Filter(lower_hsv=(0, 0, 207), upper_hsv=(0, 0, 207))\nblack_filter = Filter(lower_hsv=(0, 0, 0), upper_hsv=(0, 0, 0))\nvicitim_letter_filter = Filter(lower_hsv=(0, 0, 0), upper_hsv=(5, 255, 100))\n\nfilter_for_tuning = white_filter\n\n"""\ncv.namedWindow("trackbars")\n\ncv.createTrackbar("min_h", "trackbars", filter_for_tuning.lower[0], 255, lambda x: None)\ncv.createTrackbar("max_h", "trackbars", filter_for_tuning.upper[0], 255, lambda x: None)\n\ncv.createTrackbar("min_s", "trackbars", filter_for_tuning.lower[1], 255, lambda x: None)\ncv.createTrackbar("max_s", "trackbars", filter_for_tuning.upper[1], 255, lambda x: None)\n\ncv.createTrackbar("min_v", "trackbars", filter_for_tuning.lower[2], 255, lambda x: None)\ncv.createTrackbar("max_v", "trackbars", filter_for_tuning.upper[2], 255, lambda x: None)\n"""\ndef tune_filter(image):\n    min_h = cv.getTrackbarPos("min_h", "trackbars")\n    max_h = cv.getTrackbarPos("max_h", "trackbars")\n    min_s = cv.getTrackbarPos("min_s", "trackbars")\n    max_s = cv.getTrackbarPos("max_s", "trackbars")\n    min_v = cv.getTrackbarPos("min_v", "trackbars")\n    max_v = cv.getTrackbarPos("max_v", "trackbars")\n    filter_for_tuning = Filter((min_h, min_s, min_v), (max_h, max_s, max_v))\n    print(filter_for_tuning.lower, filter_for_tuning.upper)\n    cv.imshow("tunedImage", filter_for_tuning.filter(image))\n\n\ndef sum_images(images):\n    final_img = images[0]\n    for index, image in enumerate(images):\n        final_img += image\n        #cv.imshow(str(index), image)\n    final_img[final_img > 255] = 255\n    return final_img\n\ndef filter_victims(victims):\n    final_victims = []\n    for vic in victims:\n        if SHOW_DEBUG:\n            print("victim:", vic["position"], vic["image"].shape)\n        if vic["image"].shape[0] > 25 and vic["image"].shape[1] > 20:\n            final_victims.append(vic)\n    return final_victims\n\ndef find_victims(image):\n    """\n    Finds victims in the image.\n    Returns a list of dictionaries containing vicitims positions and images.\n    """\n    binary_images = [red_filter.filter(image), \n                    yellow_filter.filter(image), \n                    white_filter.filter(image), \n                    black_filter.filter(image)]\n\n    binary_image = sum_images(binary_images)\n    #print(binary_image)\n    if SHOW_DEBUG:\n        cv.imshow("binaryImage", binary_image)\n    \n    # Encuentra los contornos, aunque se puede confundir con el contorno de la letra\n    contours, _ = cv.findContours(binary_image, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n    # Pra evitar la confusion dibuja rectangulos blancos donde estan los contornos en la imagen y despues vuelve a\n    # sacar los contornos para obtener solo los del rectangulo, no los de las letras.\n    for c0 in contours:\n        x, y, w, h = cv.boundingRect(c0)\n        cv.rectangle(binary_image, (x, y), (x + w, y + h), (225, 255, 255), -1)\n    contours, _ = cv.findContours(binary_image, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n    # saca las medidas y la posicion de los contornos y agrega a la lista de imagenes la parte esa de la imagen original\n    # Tambien anade la posicion de cada recuadro en la imagen original\n    final_victims = []\n    for c in contours:\n        x, y, w, h = cv.boundingRect(c)\n        final_victims.append({"image":image[y:y + h, x:x + w], "position":(x, y)})\n    return filter_victims(final_victims)\n\ndef crop_white(binaryImg):\n    white = 255\n    rows, cols = np.where(binaryImg == white)\n    if len(rows) == 0 or len(cols) == 0:\n        # no white pixels found\n        return binaryImg\n    else:\n        minY, maxY = np.min(rows), np.max(rows)\n        minX, maxX = np.min(cols), np.max(cols)\n        return binaryImg[minY:maxY+1, minX:maxX+1]\n\ndef classify_victim(victim):\n    white = 255\n    img = victim["image"]\n    img =  cv.resize(img, (100, 100), interpolation=cv.INTER_AREA)\n    #conts, h = cv.findContours(thresh1, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n    binary = vicitim_letter_filter.filter(img)\n\n    letter1 = crop_white(binary)\n    letter1 = cv.resize(letter1, (100, 100), interpolation=cv.INTER_AREA)\n    letter = letter1[5:,10:90]\n    letter = crop_white(letter)\n    letter = cv.resize(letter, (100, 100), interpolation=cv.INTER_AREA)\n    if SHOW_DEBUG:\n        cv.imshow("letra", letter)\n        cv.imshow("letra1", letter1)\n        cv.imshow("thresh", binary)\n    letter_color = cv.cvtColor(letter, cv.COLOR_GRAY2BGR)\n    area_width = 20\n    area_height = 30\n    areas = {\n        "top": ((0, area_height),(50 - area_width // 2, 50 + area_width // 2)),\n        "middle": ((50 - area_height // 2, 50 + area_height // 2), (50 - area_width // 2, 50 + area_width // 2)),\n        "bottom": ((100 - area_height, 100), (50 - area_width // 2, 50 + area_width // 2 ))\n        }\n    images = {\n        "top": letter[areas["top"][0][0]:areas["top"][0][1], areas["top"][1][0]:areas["top"][1][1]],\n        "middle": letter[areas["middle"][0][0]:areas["middle"][0][1], areas["middle"][1][0]:areas["middle"][1][1]],\n        "bottom": letter[areas["bottom"][0][0]:areas["bottom"][0][1], areas["bottom"][1][0]:areas["bottom"][1][1]]\n        }\n    if SHOW_DEBUG:\n        cv.rectangle(letter_color,(areas["top"][1][0], areas["top"][0][0]), (areas["top"][1][1], areas["top"][0][1]), (0, 255, 0), 1)\n        cv.rectangle(letter_color, (areas["middle"][1][0], areas["middle"][0][0]), (areas["middle"][1][1], areas["middle"][0][1]), (0, 0, 255), 1)\n        cv.rectangle(letter_color,(areas["bottom"][1][0], areas["bottom"][0][0]), (areas["bottom"][1][1], areas["bottom"][0][1]), (225, 0, 255), 1)\n    counts = {}\n    for key in images.keys():\n        count = 0\n        for row in images[key]:\n            for pixel in row:\n                if pixel == white:\n                    count += 1\n        counts[key] = count > 20\n    letters = {\n        "H":{\'top\': False, \'middle\': True, \'bottom\': False},\n        "S":{\'top\': True, \'middle\': True, \'bottom\': True},\n        "U":{\'top\': False, \'middle\': False, \'bottom\': True}\n        }\n\n    final_letter = random.choice(list(letters.keys()))\n    for letter_key in letters.keys():\n        if counts == letters[letter_key]:\n            final_letter = letter_key\n            break\n    \n    #print(counts)\n    #print(finalLetter)\n    return final_letter\n\n\ndef is_poison(black_points, white_points):\n    return black_points < 600 and white_points > 700 and white_points < 4000\n\ndef is_victim(black_points, white_points):\n    return white_points > 5000 and 2000 > black_points > 100\n\ndef is_corrosive(black_points, white_points):\n    return 700 < white_points < 2500 and 1000 < black_points < 2500\n\ndef is_flammable(red_points, white_points):\n    return red_points and white_points\n\ndef is_organic_peroxide(red_points, yellow_points):\n    return red_points and yellow_points\n\ndef is_already_detected(point_counts):\n    if point_counts["white"] and not (point_counts["black"] + point_counts["red"] + point_counts["yellow"]):\n        return True\n\n\ndef classify_fixture(vic):\n    possible_fixture_letters = ["P", "O", "F", "C", "S", "H", "U"]\n    letter = random.choice(possible_fixture_letters)\n    image = cv.resize(vic["image"], (100, 100), interpolation=cv.INTER_AREA)\n    color_images = {\n    "red" : red_filter.filter(image),\n    "yellow" : yellow_filter.filter(image), \n    "white" : white_filter.filter(image),\n    "black" : black_filter.filter(image)}\n\n    color_point_counts = {}\n    for key, img in color_images.items():\n        all_points = np.where(img == 255)\n        all_points = all_points[0]\n        count = len(all_points)\n        color_point_counts[key] = count\n    \n    if SHOW_DEBUG:\n        print(color_point_counts)\n\n    if is_poison(color_point_counts["black"], color_point_counts["white"]):\n        print("Poison!")\n        letter = "P"\n    \n    if is_victim(color_point_counts["black"], color_point_counts["white"]):\n        cv.imshow("black filter:", color_images["black"])\n        letter = classify_victim(vic)\n        print("Victim:", letter)\n        \n    \n    if is_corrosive(color_point_counts["black"], color_point_counts["white"]):\n        print("Corrosive!")\n        letter = "C"\n    \n    if is_organic_peroxide(color_point_counts["red"], color_point_counts["yellow"]):\n        print("organic peroxide!")\n        letter = "O"\n    \n    if is_flammable(color_point_counts["red"], color_point_counts["white"]):\n        print("Flammable!")\n        letter = "F"\n    \n    if is_already_detected(color_point_counts):\n        print("Already detected!")\n        letter = None\n\n    return letter')
    __stickytape_write_module('flags.py', b'SHOW_DEBUG = False')
    __stickytape_write_module('utilities.py', b'import math\nimport cv2 as cv\nimport numpy as np\nimport os\nfrom functools import wraps\n\nscript_dir = os.path.dirname(__file__)\nimage_dir = os.path.join(script_dir, "images")\n\ndef save_image(image, filename):\n    cv.imwrite(os.path.join(image_dir, filename), image)\n\n# Corrects the given angle in degrees to be in a range from 0 to 360\ndef normalizeDegs(ang):\n    ang = ang % 360\n    if ang < 0:\n        ang += 360\n    if ang == 360:\n        ang = 0\n    return ang\n\n# Corrects the given angle in radians to be in a range from 0 to a full rotaion\ndef normalizeRads(rad):\n    ang = radsToDegs(rad)\n    normAng = normalizeDegs(ang)\n    return degsToRads(normAng)\n\n# Converts from degrees to radians\ndef degsToRads(deg):\n    return deg * math.pi / 180\n\n# Converts from radians to degrees\ndef radsToDegs(rad):\n    return rad * 180 / math.pi\n\n# Converts a number from a range of value to another\ndef mapVals(val, in_min, in_max, out_min, out_max):\n    return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min\n\n# Gets x, y coordinates from a given angle in radians and distance\ndef getCoordsFromRads(rad, distance):\n    y = float(distance * math.cos(rad))\n    x = float(distance * math.sin(rad))\n    return (x, y)\n\n# Gets x, y coordinates from a given angle in degrees and distance\ndef getCoordsFromDegs(deg, distance):\n    rad = degsToRads(deg)\n    y = float(distance * math.cos(rad))\n    x = float(distance * math.sin(rad))\n    return (x, y)\n\ndef getRadsFromCoords(coords):\n    return math.atan2(coords[0], coords[1])\n\n\ndef getDegsFromCoords(coords):\n    rads = math.atan2(coords[0], coords[1])\n    return radsToDegs(rads)\n\n# Gets the distance to given coordinates\ndef getDistance(position):\n    return math.sqrt((position[0] ** 2) + (position[1] ** 2))\n\n# Checks if a value is between two values\ndef isInRange(val, minVal, maxVal):\n    return minVal < val < maxVal\n\ndef roundDecimal(number, decimal):\n    return (round(number * decimal) / decimal)\n\ndef multiplyLists(list1, list2):\n    finalList = []\n    for item1, item2 in zip(list1, list2):\n        finalList.append(item1 * item2)\n    return finalList\n\ndef sumLists(list1, list2):\n    finalList = []\n    for item1, item2 in zip(list1, list2):\n        finalList.append(item1 + item2)\n    return finalList\n\ndef substractLists(list1, list2):\n    finalList = []\n    for item1, item2 in zip(list1, list2):\n        finalList.append(item1 - item2)\n    return finalList\n\ndef divideLists(list1, list2):\n    finalList = []\n    for item1, item2 in zip(list1, list2):\n        finalList.append(item1 / item2)\n    return finalList\n\n\ndef draw_grid(image, square_size, offset = [0,0], color=255):\n    for y, row in enumerate(image):\n        for x, pixel in enumerate(row):\n            if (y + offset[1]) % square_size == 0 or (x + offset[0]) % square_size == 0:\n                if len(image.shape) == 3:\n                    image[y][x][:] = color\n                else:\n                    image[y][x] = color\n\ndef draw_poses(image, poses, color=255, back_image=None, xx_yy_format=False):\n    if xx_yy_format:\n        if back_image is not None:\n            in_bounds_x = (poses[0] < min(image.shape[0], back_image.shape[0]) - 1) & (poses[0] > 0)\n            in_bounds_y = (poses[1] < min(image.shape[1], back_image.shape[1]) - 1) & (poses[1] > 0)\n        else:\n            in_bounds_x = (poses[0] < image.shape[0] - 1) & (poses[0] > 0)\n            in_bounds_y = (poses[1] < image.shape[1] - 1) & (poses[1] > 0)\n        \n        poses = (poses[0][in_bounds_x & in_bounds_y], poses[1][in_bounds_x & in_bounds_y])\n\n        if back_image is None:\n            image[poses[1], poses[0], :] = color\n        else:\n            image[poses[1], poses[0], :] = back_image[poses[1], poses[0], :]\n        \n    else:\n        in_bounds = (poses[:, 0] >= 0) & (poses[:, 0] < image.shape[1]) & (poses[:, 1] >= 0) & (poses[:, 1] < image.shape[0])\n        poses = poses[in_bounds]\n\n        if back_image is None:\n            image[poses[:, 1], poses[:, 0], :] = color\n        else:\n            image[poses[:, 1], poses[:, 0], :] = back_image[poses[:, 1], poses[:, 0], :]\n            \n\ndef draw_squares_where_not_zero(image, square_size, offsets, color=(255, 255, 255)):\n    ref_image = image.copy()\n    for y in range(image.shape[0] // square_size):\n        for x in range(image.shape[1] // square_size):\n            square_points = [\n                (y * square_size)        + (square_size - offsets[1]),\n                ((y + 1) * square_size)  + (square_size - offsets[1]), \n                (x * square_size)        + (square_size - offsets[0]),\n                ((x + 1) * square_size)  + (square_size - offsets[0])]\n            square = ref_image[square_points[0]:square_points[1], square_points[2]:square_points[3]]\n            non_zero_count = np.count_nonzero(square)\n            if non_zero_count > 0:\n                #print("Non zero count: ", non_zero_count)\n                #print("max: ", np.max(square))\n                cv.rectangle(image, (square_points[2], square_points[0]), (square_points[3], square_points[1]), color, 3)\n\ndef get_squares(image, square_size, offsets):\n    grid = []\n    for y in range(image.shape[0] // square_size):\n        row = []\n        for x in range(image.shape[1] // square_size):\n            square_points = [\n                (y * square_size)        + (square_size - offsets[1]),\n                ((y + 1) * square_size)  + (square_size - offsets[1]), \n                (x * square_size)        + (square_size - offsets[0]),\n                ((x + 1) * square_size)  + (square_size - offsets[0])]\n            row.append(square_points)\n        grid.append(row)\n    return grid\n\ndef resize_image_to_fixed_size(image, size):\n    if image.shape[0] > size[0]:\n        ratio = size[0] / image.shape[0]\n\n        width = round(image.shape[1] * ratio)\n        final_image = cv.resize(image.astype(np.uint8), dsize=(width, size[0]))\n    \n    elif image.shape[1] > size[1]:\n        ratio = size[1] / image.shape[1]\n\n        height = round(image.shape[0] * ratio)\n        final_image = cv.resize(image.astype(np.uint8), dsize=(size[1], height))\n    \n    elif image.shape[1] >= image.shape[0]:\n        ratio = size[1] / image.shape[1]\n\n        height = round(image.shape[0] * ratio)\n        final_image = cv.resize(image.astype(np.uint8), dsize=(size[1], height), interpolation=cv.INTER_NEAREST)\n    \n    elif image.shape[0] >= image.shape[1]:\n        ratio = size[0] / image.shape[0]\n\n        width = round(image.shape[1] * ratio)\n        final_image = cv.resize(image.astype(np.uint8), dsize=(width, size[0]), interpolation=cv.INTER_NEAREST)\n    \n    return final_image\n\ndef dir2list(direction):\n    directions = {\n        "up": [0, -1],\n        "down": [0, 1],\n        "left": [-1, 0],\n        "right": [1, 0],\n        "up_left": [-1, -1],\n        "up_right": [1, -1],\n        "down_left": [-1, 1],\n        "down_right": [1, 1],\n        "u": [0, -1],\n        "d": [0, 1],\n        "l": [-1, 0],\n        "r": [1, 0],\n        "ul": [-1, -1],\n        "ur": [1, -1],\n        "dl": [-1, 1],\n        "dr": [1, 1]\n    }\n    return directions[direction]\n\ndef list2dir(direction):\n    direction = tuple(direction)\n    directions = {\n        (0, -1): "up",\n        (0, 1): "down",\n        (-1, 0): "left",\n        (1, 0): "right",\n        (-1, -1): "up_left",\n        (1, -1): "up_right",\n        (-1, 1): "down_left",\n        (1, 1): "down_right",\n        (0, -1): "u",\n        (0, 1): "d",\n        (-1, 0): "l",\n        (1, 0): "r",\n        (-1, -1): "ul",\n        (1, -1): "ur",\n        (-1, 1): "dl",\n        (1, 1): "dr"\n    }\n    return directions[direction]\n\ndef is_color_in_range(color, rng):\n    minimums = rng[0]\n    maximums = rng[1]\n    for i, c in enumerate(color):\n        if c < minimums[i] or c > maximums[i]:\n            return False\n    return True\n\n\ndef do_every_n_frames(n, time_step):\n    def inner_function(func):\n        @wraps(func)\n        def wrapper(self, current_time, *args, **kwargs):\n            if (current_time // (time_step / 1000)) % n == 0:\n                return func(self, *args, **kwargs)\n        return wrapper\n    return inner_function')
    __stickytape_write_module('state_machines.py', b'from flags import SHOW_DEBUG\n\n# Manages states\nclass StateManager:\n    def __init__(self, initialState):\n        self.state = initialState\n\n    # Sets the state to a certain value\n    def changeState(self, newState):\n        self.state = newState\n        return True\n\n    # Checks if the state corresponds to a specific value\n    def checkState(self, state):\n        return self.state == state\n\n# Makes it possible to run arbitrary code sequentially without interrupting other code that must run continuoulsy\nclass SequenceManager:\n    def __init__(self, resetFunction=None):\n        self.lineIdentifier = 0\n        self.linePointer = 1\n        self.done = False\n        self.resetFunction = resetFunction\n\n    # Resets the sequence and makes it start from the first event\n    def resetSequence(self):\n        if self.resetFunction is not None:\n            self.resetFunction()\n        self.linePointer = 1\n        if SHOW_DEBUG:\n            print("----------------")\n            print("reseting sequence")\n            print("----------------")\n\n    def seqResetSequence(self):\n        if self.check():\n            self.resetSequence()\n            \n            return True\n        return False\n\n    # This has to be at the start of any sequence of events\n    def startSequence(self):\n        self.lineIdentifier = 0\n        self.done = False\n\n    # Returns if the line pointer and identifier match and increases the identifier\n    # Must be included at the end of any sequential function\n    def check(self):\n        self.done = False\n        self.lineIdentifier += 1\n        return self.lineIdentifier == self.linePointer\n\n    # Changes to the next event\n    def nextSeq(self):\n        self.linePointer += 1\n        self.done = True\n\n    # returns if the sequence has reached its end\n    def seqDone(self):\n        return self.done\n\n    # Can be used to make a function sequential or used in an if statement to make a code block sequential\n    def simpleEvent(self, function=None, *args, **kwargs):\n        if self.check():\n            if function is not None:\n                function(*args, **kwargs)\n            self.nextSeq()\n            return True\n        return False\n\n    # The function inputted must return True when it ends\n    def complexEvent(self, function, *args, **kwargs):\n        if self.check():\n            if function(*args, **kwargs):\n                self.nextSeq()\n                return True\n        return False\n    \n    # When inpuuted any function it returns a sequential version of it that can be used in a sequence\n    def makeSimpleEvent(self, function):\n        def event(*args, **kwargs):\n            if self.check():\n                function(*args, **kwargs)\n                self.nextSeq()\n                return True\n            return False\n        return event\n\n    # When inputted a function that returns True when it ends returns a sequential version of it that can be used in a sequence\n    def makeComplexEvent(self, function):\n        def event(*args, **kwargs):\n            if self.check():\n                if function(*args, **kwargs):\n                    self.nextSeq()\n                    return True\n            return False\n        return event\n')
    __stickytape_write_module('robot.py', b'# In charge of low level movement\nfrom controller import Robot\n\nimport utilities\n\n# devices\nfrom devices.wheel import Wheel\n\nfrom devices.camera import Camera\nfrom devices.colour_sensor import ColourSensor\n\nfrom devices.lidar import Lidar\n\nfrom devices.gps import Gps\nfrom devices.gyroscope import Gyroscope\n\nfrom devices.comunicator import Comunicator\n\nfrom flags import SHOW_DEBUG\n\n# Abstraction layer for robot\nclass RobotLayer:\n    def __init__(self, time_step):\n        # Maximum wheel speed\n        self.max_wheel_speed = 6.28\n        # The timestep\n        self.time_step = time_step\n\n        self.diameter = 0.074\n        # Robot object provided by webots\n        self.robot = Robot()\n        self.prev_rotation = 0\n        self.rotation = 0\n        self.position = [0, 0]\n        self.prev_global_position = [0, 0]\n        self.position_offsets = [0, 0]\n\n        self.rotation_sensor = "gyro"\n\n        self.time = 0\n        self.rotate_to_degs_first_time = True\n        self.delay_first_time = True\n        self.delay_start = self.robot.getTime()\n\n        self.auto_decide_rotation = True\n        self.gyroscope = Gyroscope(self.robot.getDevice("gyro"), 1, self.time_step)\n        self.gps = Gps(self.robot.getDevice("gps"), self.time_step)\n        self.lidar = Lidar(self.robot.getDevice("lidar"), self.time_step, 0.03, (0, 360))\n        self.left_wheel = Wheel(self.robot.getDevice("wheel1 motor"), self.max_wheel_speed)\n        self.right_wheel = Wheel(self.robot.getDevice("wheel2 motor"), self.max_wheel_speed)\n\n        self.comunicator = Comunicator(self.robot.getDevice("emitter"), self.robot.getDevice("receiver"), self.time_step)\n        self.center_camera = Camera(self.robot.getDevice("camera1"), self.time_step)\n        self.right_camera = Camera(self.robot.getDevice("camera2"), self.time_step)\n        self.left_camera = Camera(self.robot.getDevice("camera3"), self.time_step)\n        \n\n        self.point_is_close = False\n\n        self.stuck_counter = 0\n\n    def delay_sec(self, delay):\n        if SHOW_DEBUG:\n            print("Current delay: ", delay)\n        if self.delay_first_time:\n            self.delay_start = self.robot.getTime()\n            self.delay_first_time = False\n        else:\n            if self.time - self.delay_start >= delay:\n                \n                self.delay_first_time = True\n                return True\n        return False\n\n    # Moves the wheels at the specified ratio\n    def move_wheels(self, left_ratio, right_ratio):\n        self.left_wheel.move(left_ratio)\n        self.right_wheel.move(right_ratio)\n\n    def rotate_to_degs(self, degs, orientation="closest", max_speed=0.5):\n        accuracy = 2\n        if self.rotate_to_degs_first_time:\n            # print("STARTED ROTATION")\n            self.rotate_to_degs_first_time = False\n        self.seqRotateToDegsInitialRot = self.rotation\n        self.seqRotateToDegsinitialDiff = round(self.seqRotateToDegsInitialRot - degs)\n        diff = self.rotation - degs\n        moveDiff = max(round(self.rotation), degs) - min(self.rotation, degs)\n        if diff > 180 or diff < -180:\n            moveDiff = 360 - moveDiff\n        speedFract = min(utilities.mapVals(moveDiff, accuracy, 90, 0.2, 0.8), max_speed)\n        if accuracy * -1 < diff < accuracy or 360 - accuracy < diff < 360 + accuracy:\n            self.rotate_to_degs_first_time = True\n            return True\n        else:\n            if orientation == "closest":\n                if 180 > self.seqRotateToDegsinitialDiff > 0 or self.seqRotateToDegsinitialDiff < -180:\n                    direction = "right"\n                else:\n                    direction = "left"\n            elif orientation == "farthest":\n                if 180 > self.seqRotateToDegsinitialDiff > 0 or self.seqRotateToDegsinitialDiff < -180:\n                    direction = "left"\n                else:\n                    direction = "right"\n            else:\n                direction = orientation\n\n            if moveDiff > 10:\n                if direction == "right":\n                    self.move_wheels(speedFract * -1, speedFract)\n                elif direction == "left":\n                    self.move_wheels(speedFract, speedFract * -1)\n            else:\n                if direction == "right":\n                    self.move_wheels(speedFract * -0.5, speedFract)\n                elif direction == "left":\n                    self.move_wheels(speedFract, speedFract * -0.5)\n            # print("speed fract: " +  str(speedFract))\n            # print("target angle: " +  str(degs))\n            # print("moveDiff: " + str(moveDiff))\n            # print("diff: " + str(diff))\n            # print("orientation: " + str(orientation))\n            # print("direction: " + str(direction))\n            # print("initialDiff: " + str(self.seqRotateToDegsinitialDiff))\n\n        # print("ROT IS FALSE")\n        return False\n    \n    def rotate_smoothly_to_degs(self, degs, orientation="closest", maxSpeed=0.5):\n        accuracy = 2\n        seqRotateToDegsinitialDiff = round(self.rotation - degs)\n        diff = self.rotation - degs\n        moveDiff = max(round(self.rotation), degs) - min(self.rotation, degs)\n        if diff > 180 or diff < -180:\n            moveDiff = 360 - moveDiff\n        speedFract = min(utilities.mapVals(moveDiff, accuracy, 90, 0.2, 0.8), maxSpeed)\n        if accuracy * -1 < diff < accuracy or 360 - accuracy < diff < 360 + accuracy:\n            self.rotate_to_degs_first_time = True\n            return True\n        else:\n            if orientation == "closest":\n                if 180 > seqRotateToDegsinitialDiff > 0 or seqRotateToDegsinitialDiff < -180:\n                    direction = "right"\n                else:\n                    direction = "left"\n            elif orientation == "farthest":\n                if 180 > seqRotateToDegsinitialDiff > 0 or seqRotateToDegsinitialDiff < -180:\n                    direction = "left"\n                else:\n                    direction = "right"\n            else:\n                direction = orientation\n            if direction == "right":\n                self.move_wheels(speedFract * -0.5, speedFract)\n            elif direction == "left":\n                self.move_wheels(speedFract, speedFract * -0.5)\n            # print("speed fract: " +  str(speedFract))\n            # print("target angle: " +  str(degs))\n            # print("moveDiff: " + str(moveDiff))\n            # print("diff: " + str(diff))\n            # print("orientation: " + str(orientation))\n            # print("direction: " + str(direction))\n            # print("initialDiff: " + str(seqRotateToDegsinitialDiff))\n\n        # print("ROT IS FALSE")\n        return False\n\n    def move_to_coords(self, targetPos):\n        errorMargin = 0.01\n        descelerationStart = 0.5 * 0.12\n        diffX = targetPos[0] - self.position[0]\n        diffY = targetPos[1] - self.position[1]\n        # print("Target Pos: ", targetPos)\n        # print("Used global Pos: ", self.position)\n        # print("diff in pos: " + str(diffX) + " , " + str(diffY))\n        dist = utilities.getDistance((diffX, diffY))\n        if SHOW_DEBUG: print("Dist: "+ str(dist))\n        if errorMargin * -1 < dist < errorMargin:\n            # self.robot.move(0,0)\n            if SHOW_DEBUG: print("FinisehedMove")\n            return True\n        else:\n            \n            ang = utilities.getDegsFromCoords((diffX, diffY))\n            ang = utilities.normalizeDegs(ang)\n            # print("traget ang: " + str(ang))\n            ratio = min(utilities.mapVals(dist, 0, descelerationStart, 0.1, 1), 1)\n            ratio = max(ratio, 0.8)\n            if self.rotate_to_degs(ang):\n                self.move_wheels(ratio, ratio)\n                # print("Moving")\n        return False\n    \n    # Gets a point cloud with all the detections from lidar and distance sensors\n    \n    def get_detection_point_cloud(self):\n        point_clouds = self.lidar.getPointCloud(self.time, layers=(2, 3))\n        self.point_is_close = self.lidar.pointIsClose\n        return point_clouds\n    \n    def get_camera_images(self):\n        return [self.right_camera.getImg(), self.center_camera.getImg(), self.left_camera.getImg()]\n    \n    # Returns True if the simulation is running\n    def do_loop(self):\n        return self.robot.step(self.time_step) != -1\n    \n    def get_wheel_direction(self):\n        if self.right_wheel.velocity + self.left_wheel.velocity == 0:\n            return 0\n        return (self.right_wheel.velocity + self.left_wheel.velocity) / 2\n    \n    def is_stuck_this_step(self):\n        return self.get_wheel_direction() > 0 and abs(utilities.getDistance(utilities.substractLists(self.position, self.prev_global_position))) < 0.00001\n\n    def is_stuck(self):\n        return self.stuck_counter > 50\n\n    # Must run every TimeStep\n    def update(self):\n        # Updates the current time\n        self.time = self.robot.getTime()\n        # Updates the gps, gyroscope\n        self.gps.update()\n        self.gyroscope.update(self.time)\n\n        # Gets global position\n        self.prev_global_position = self.position\n        self.position = self.gps.getPosition()\n        self.position[0] += self.position_offsets[0]\n        self.position[1] += self.position_offsets[1]\n\n        # Decides wich sensor to use for roatation detection\n        # if the robot is going srtaight i tuses the gps\n        \n        if self.auto_decide_rotation:\n            if self.gyroscope.getDiff() < 0.00001 and self.get_wheel_direction() >= 0:\n                self.rotation_sensor = "gps"\n            # if it isn\'t going straight it uses the gyro\n            else:\n                self.rotation_sensor = "gyro"\n\n        # Remembers the corrent rotation for the next timestep\n        self.prev_rotation = self.rotation\n\n        # Gets global rotation\n        if self.rotation_sensor == "gyro":\n            self.rotation = self.gyroscope.getDegrees()\n            if SHOW_DEBUG:\n                print("USING GYRO")\n        else:\n            if SHOW_DEBUG:\n                print("USING GPS")\n            val = self.gps.getRotation()\n            if val is not None:\n                self.rotation = val\n            self.gyroscope.setDegrees(self.rotation)\n\n        # Sets lidar rotation\n        self.lidar.setRotationDegrees(self.rotation + 0)\n\n        #print("Delay time:", self.time - self.delayStart)\n\n        if self.is_stuck_this_step():\n            self.stuck_counter += 1\n        else:\n            self.stuck_counter = 0\n')
    __stickytape_write_module('devices/wheel.py', b'# Controlls a wheel\nclass Wheel:\n    def __init__(self, wheel, maxVelocity):\n        self.maxVelocity = maxVelocity\n        self.wheel = wheel\n        self.velocity = 0\n        self.wheel.setPosition(float("inf"))\n        self.wheel.setVelocity(0)\n\n    # Moves the wheel at a ratio of the maximum speed (between 0 and 1)\n    def move(self, ratio):\n        if ratio > 1:\n            ratio = 1\n        elif ratio < -1:\n            ratio = -1\n        self.velocity = ratio * self.maxVelocity\n        self.wheel.setVelocity(self.velocity)')
    __stickytape_write_module('devices/camera.py', b'import numpy as np\n\n# Captures images and processes them\nclass Camera:\n    def __init__(self, camera, timeStep):\n        self.camera = camera\n        self.camera.enable(timeStep)\n        self.height = self.camera.getHeight()\n        self.width = self.camera.getWidth()\n\n    # Gets an image from the raw camera data\n    def getImg(self):\n        imageData = self.camera.getImage()\n        return np.array(np.frombuffer(imageData, np.uint8).reshape((self.height, self.width, 4)))')
    __stickytape_write_module('devices/colour_sensor.py', b'import utilities\n\n# Reads the colour sensor\nclass ColourSensor:\n    def __init__(self, sensor, distancefromCenter, timeStep):\n        self.distance = distancefromCenter\n        self.position = [0, 0]\n        self.sensor = sensor\n        self.sensor.enable(timeStep)\n        self.r = 0\n        self.g = 0\n        self.b = 0\n    \n    def setPosition(self, robotGlobalPosition, robotGlobalRotation):\n        realPosition = utilities.getCoordsFromDegs(robotGlobalRotation, self.distance)\n        self.position = [robotGlobalPosition[0] + realPosition[0], robotGlobalPosition[1] + realPosition[1]]\n    \n    def __update(self):\n        colour = self.sensor.getImage()\n        # print("Colourimg:", colour)\n        self.r = self.sensor.imageGetRed(colour, 1, 0, 0)\n        self.g = self.sensor.imageGetGreen(colour, 1, 0, 0)\n        self.b = self.sensor.imageGetBlue(colour, 1, 0, 0)\n        # print("Colour:", self.r, self.g, self.b)\n    \n    def __isTrap(self):\n        return (35 < self.r < 45 and 35 < self.g < 45)\n\n    def __isSwamp(self):\n        return (200 < self.r < 210 and 165 < self.g < 175 and 95 < self.b < 105)\n\n    def __isCheckpoint(self):\n        return (self.r > 232 and self.g > 232 and self.b > 232)\n\n    def __isNormal(self):\n        return self.r == 227 and self.g == 227\n\n    def __isBlue(self):\n        return (55 < self.r < 65 and 55 < self.g < 65 and 245 < self.b < 255)\n\n    def __isPurple(self):\n        return (135 < self.r < 145 and 55 < self.g < 65 and 215 < self.b < 225)\n\n    def __isRed(self):\n        return (245 < self.r < 255 and 55 < self.g < 65 and 55 < self.b < 65)\n\n    # Returns the type of tyle detected from the colour data\n    def getTileType(self):\n        self.__update()\n        tileType = "undefined"\n        if self.__isNormal():\n            tileType = "normal"\n        elif self.__isTrap():\n            tileType = "hole"\n        elif self.__isSwamp():\n            tileType = "swamp"\n        elif self.__isCheckpoint():\n            tileType = "checkpoint"\n        elif self.__isBlue():\n            tileType = "connection1-2"\n        elif self.__isPurple():\n            tileType = "connection2-3"\n        elif self.__isRed():\n            tileType = "connection1-3"\n\n        # print("Color: " + tileType)\n        # print("r: " + str(self.r) + "g: " + str(self.g) + "b: " +  str(self.b))\n        return tileType')
    __stickytape_write_module('devices/lidar.py', b'import utilities\nimport math\n\n# Returns a point cloud of the detctions it makes\nclass Lidar():\n    def __init__(self, device, timeStep, pointIsCloseThresh, pointIsCloseRange):\n        self.device = device\n        self.device.enable(timeStep)\n        self.x = 0\n        self.y = 0\n        self.z = 0\n        self.rotation = 0\n        self.fov = device.getFov()\n        self.verticalFov = self.device.getVerticalFov()\n        self.horizontalRes = self.device.getHorizontalResolution()\n        self.verticalRes = self.device.getNumberOfLayers()\n        self.hRadPerDetection = self.fov / self.horizontalRes\n        self.vRadPerDetection = self.verticalFov / self.verticalRes\n        self.detectRotOffset = 0  # math.pi * 0.75\n        self.maxDetectionDistance = 0.06 * 5\n        self.minDetectionDistance = 0.06 * 0.5\n        self.pointIsClose = False\n        self.pointIsCloseThresh = pointIsCloseThresh\n        self.pointIsCloseRange = pointIsCloseRange\n        self.distBias = 0.06 * 0.2\n        self.distCoeff = 1\n        self.distFactor = 1 #0.8\n    \n    def getRotationsAndDistances(self, layers=range(3)):\n        self.pointIsClose = False\n        \n        # (degsToRads(359 - radsToDegs(self.rotation)))\n        # rangeImage = self.device.getRangeImageArray()\n        # print("Lidar vFov: ", self.verticalFov/ self.verticalRes)\n\n        rots = []\n        distances = []\n        \n        for layer in layers:\n            actualVDetectionRot = (layer * self.vRadPerDetection) + self.verticalFov / 2\n            depthArray = self.device.getLayerRangeImage(layer)\n            actualHDetectionRot = self.detectRotOffset + ((2 * math.pi) - self.rotation)\n            for item in depthArray:\n                if self.minDetectionDistance <= item:# <= self.maxDetectionDistance:\n\n                    if item == float("inf") or item == float("inf") * -1:\n                        item = 0.5\n                    x = item * math.cos(actualVDetectionRot)\n                    \n                    x += self.distBias\n                    x *= self.distCoeff\n                    x = x ** self.distFactor\n\n\n                    if utilities.degsToRads(self.pointIsCloseRange[0]) > actualHDetectionRot > utilities.degsToRads(self.pointIsCloseRange[1]) and x < self.pointIsCloseThresh:\n                        self.pointIsClose = True\n\n                    rots.append(actualHDetectionRot)\n                    distances.append(x)\n                actualHDetectionRot += self.hRadPerDetection\n        return rots, distances\n\n\n    # Does a detection pass and returns a point cloud with the results\n    @utilities.do_every_n_frames(5, 32)\n    def getPointCloud(self, layers=range(3)):\n        self.pointIsClose = False\n        \n        # (degsToRads(359 - radsToDegs(self.rotation)))\n        # rangeImage = self.device.getRangeImageArray()\n        # print("Lidar vFov: ", self.verticalFov/ self.verticalRes)\n\n        pointCloud = []\n\n        outOfBounds = []\n        \n        for layer in layers:\n            actualVDetectionRot = (layer * self.vRadPerDetection) + self.verticalFov / 2\n            depthArray = self.device.getLayerRangeImage(layer)\n            actualHDetectionRot = self.detectRotOffset + ((2 * math.pi) - self.rotation)\n            for item in depthArray:\n                if item >= self.maxDetectionDistance or item == float("inf"):\n                    x = 10 * math.cos(actualVDetectionRot)\n                    x += self.distBias\n                    x *= self.distCoeff\n                    x = x ** self.distFactor\n\n                    coords = utilities.getCoordsFromRads(actualHDetectionRot, x)\n                    outOfBounds.append([coords[0] - 0, (coords[1] * -1) - 0])\n\n                else:\n                    if item >= self.minDetectionDistance:\n                            #item = self.maxDetectionDistance\n                            if item != float("inf") and item != float("inf") * -1 and item != 0:\n                                x = item * math.cos(actualVDetectionRot)\n                                x += self.distBias\n                                x *= self.distCoeff\n                                x = x ** self.distFactor\n\n                                if utilities.degsToRads(self.pointIsCloseRange[0]) > actualHDetectionRot > utilities.degsToRads(self.pointIsCloseRange[1]) and x < self.pointIsCloseThresh:\n                                    self.pointIsClose = True\n\n                                coords = utilities.getCoordsFromRads(actualHDetectionRot, x)\n                                pointCloud.append([coords[0] - 0, (coords[1] * -1) - 0])\n\n                actualHDetectionRot += self.hRadPerDetection\n        if len(outOfBounds) == 0:\n            outOfBounds = [[0, 0]]\n        \n        if len(pointCloud) == 0:\n            pointCloud = [[0, 0]]\n\n        return pointCloud, outOfBounds\n\n    # Sets the rotation of the sensors in radians\n    def setRotationRadians(self, rads):\n        self.rotation = rads\n    \n    # Sets the rotation of the sensors in degrees\n    def setRotationDegrees(self, degs):\n        self.rotation = utilities.degsToRads(degs)')
    __stickytape_write_module('devices/gps.py', b'import utilities\n\n# Tracks global position\nclass Gps:\n    def __init__(self, gps, timeStep, coordsMultiplier=1):\n        self.gps = gps\n        self.gps.enable(timeStep)\n        self.multiplier = coordsMultiplier\n        self.__prevPosition = []\n        self.position = self.getPosition()\n\n    # updates gps, must run every timestep\n    def update(self):\n        self.__prevPosition = self.position\n        self.position = self.getPosition()\n\n    # Returns the global position\n    def getPosition(self):\n        vals = self.gps.getValues()\n        return [vals[0] * self.multiplier, vals[2] * self.multiplier]\n\n    # Returns the global rotation according to gps\n    def getRotation(self):\n        if self.__prevPosition != self.position:\n            posDiff = ((self.position[0] - self.__prevPosition[0]), (self.position[1] - self.__prevPosition[1]))\n            accuracy = utilities.getDistance(posDiff)\n            if accuracy > 0.001:\n                degs = utilities.getDegsFromCoords(posDiff)\n                return utilities.normalizeDegs(degs)\n        return None')
    __stickytape_write_module('devices/gyroscope.py', b'import utilities\n\n# Tracks global rotation\nclass Gyroscope:\n    def __init__(self, gyro, index, timeStep):\n        self.sensor = gyro\n        self.sensor.enable(timeStep)\n        self.oldTime = 0.0\n        self.index = index\n        self.rotation = 0\n        self.lastRads = 0\n\n    # Do on every timestep\n    def update(self, time):\n        timeElapsed = time - self.oldTime  # Time passed in time step\n        radsInTimestep = (self.sensor.getValues())[self.index] * timeElapsed\n        self.lastRads = radsInTimestep\n        finalRot = self.rotation + radsInTimestep\n        self.rotation = utilities.normalizeRads(finalRot)\n        self.oldTime = time\n\n    # Gets the actual angular Velocity\n    def getDiff(self):\n        if self.lastRads < 0:\n            return self.lastRads * -1\n        \n        return self.lastRads\n\n    # Returns the rotation on degrees\n    def getDegrees(self):\n        return utilities.radsToDegs(self.rotation)\n\n    # Returns the rotation on radians\n    def getRadians(self):\n        return self.rotation\n\n    # Sets the rotation in radians\n    def setRadians(self, rads):\n        self.rotation = rads\n\n    # Sets the rotation in degrees\n    def setDegrees(self, degs):\n        self.rotation = utilities.degsToRads(degs)')
    __stickytape_write_module('devices/comunicator.py', b'import utilities\nimport struct\n\nclass Comunicator:\n    def __init__(self, emmiter, receiver, timeStep):\n        self.receiver = receiver\n        self.emmiter = emmiter\n        self.receiver.enable(timeStep)\n        self.lackOfProgress = False\n        self.doGetWordInfo = True\n        self.gameScore = 0\n        self.remainingTime = 0\n\n    def sendVictim(self, position, victimtype):\n        self.doGetWordInfo = False\n        letter = bytes(victimtype, "utf-8")\n        position = utilities.multiplyLists(position, [100, 100])\n        position = [int(position[0]), int(position[1])]\n        message = struct.pack("i i c", position[0], position[1], letter)\n        self.emmiter.send(message)\n        self.doGetWordInfo = False\n\n    def sendLackOfProgress(self):\n        self.doGetWordInfo = False\n        message = struct.pack(\'c\', \'L\'.encode())  # message = \'L\' to activate lack of progress\n        self.emmiter.send(message)\n        self.doGetWordInfo = False\n\n    def sendEndOfPlay(self):\n        self.doGetWordInfo = False\n        exit_mes = struct.pack(\'c\', b\'E\')\n        self.emmiter.send(exit_mes)\n        print("Ended!!!!!")\n\n    def sendMap(self, npArray):\n        # Get shape\n        print(npArray)\n        s = npArray.shape\n        # Get shape as bytes\n        s_bytes = struct.pack(\'2i\', *s)\n        # Flattening the matrix and join with \',\'\n        flatMap = \',\'.join(npArray.flatten())\n        # Encode\n        sub_bytes = flatMap.encode(\'utf-8\')\n        # Add togeather, shape + map\n        a_bytes = s_bytes + sub_bytes\n        # Send map data\n        self.emmiter.send(a_bytes)\n        # STEP3 Send map evaluate request\n        map_evaluate_request = struct.pack(\'c\', b\'M\')\n        self.emmiter.send(map_evaluate_request)\n        self.doGetWordInfo = False\n\n    def requestGameData(self):\n        if self.doGetWordInfo:\n            message = struct.pack(\'c\', \'G\'.encode())  # message = \'G\' for game information\n            self.emmiter.send(message)  # send message\n\n    def update(self):\n\n        if self.doGetWordInfo:\n            self.requestGameData()\n            if self.receiver.getQueueLength() > 0: # If receiver queue is not empty\n                receivedData = self.receiver.getData()\n                if len(receivedData) > 2:\n                    tup = struct.unpack(\'c f i\', receivedData) # Parse data into char, float, int\n                    if tup[0].decode("utf-8") == \'G\':\n                        self.gameScore = tup[1]\n                        self.remainingTime = tup[2]\n                        self.receiver.nextPacket() # Discard the current data packet\n\n            self.lackOfProgress = False\n            if self.receiver.getQueueLength() > 0:  # If receiver queue is not empty\n                receivedData = self.receiver.getData()\n                print(receivedData)\n                if len(receivedData) < 2:\n                    tup = struct.unpack(\'c\', receivedData)  # Parse data into character\n                    if tup[0].decode("utf-8") == \'L\':  # \'L\' means lack of progress occurred\n                        print("Detected Lack of Progress!")\n                        self.lackOfProgress = True\n                    self.receiver.nextPacket()  # Discard the current data packetelse:\n        else:\n            self.doGetWordInfo = True')
    __stickytape_write_module('mapping.py', b'import numpy as np\nimport copy\nimport cv2 as cv\nimport math\n\nimport utilities\nfrom data_processing import camera_processor, data_extractor, point_cloud_processor\nfrom data_structures import lidar_persistent_grid, expandable_node_grid\nfrom algorithms.expandable_node_grid.bfs import bfs\n\nfrom flags import SHOW_DEBUG\n\nclass Mapper:\n    def __init__(self, tile_size):\n        self.tile_size = tile_size\n\n        # Data structures\n        self.node_grid = expandable_node_grid.Grid((1, 1))\n        self.lidar_grid = lidar_persistent_grid.LidarGrid(tile_size, 6, 100)\n\n        res = 50 / tile_size\n\n        # Data processors\n        self.point_cloud_processor = point_cloud_processor.PointCloudProcessor(350, res)\n        self.camera_processor = camera_processor.CameraProcessor(100)\n\n        # Data extractors\n        self.point_cloud_extractor = data_extractor.PointCloudExtarctor(resolution=6)\n        self.floor_color_extractor = data_extractor.FloorColorExtractor(50)\n\n        self.robot_node = None\n        self.robot_vortex_center = None\n\n        self.start_node = None\n    \n    def register_start(self, robot_position):\n        robot_vortex = [int((x + 0.03) // self.tile_size) for x in robot_position]\n        robot_node = [int(t * 2) for t in robot_vortex]\n        self.start_node = robot_node\n        for adj in ((1, 1), (1, -1), (-1, 1), (-1, -1)):\n            adj = utilities.sumLists(robot_node, adj)\n            self.node_grid.get_node(adj).tile_type = "start"\n        self.node_grid.get_node(robot_node).is_start = True\n    \n    @utilities.do_every_n_frames(5, 32)\n    def load_point_cloud(self, point_cloud, robot_position):\n        point_cloud = self.point_cloud_processor.processPointCloud(point_cloud, robot_position)\n        self.lidar_grid.update(point_cloud)\n    \n    @utilities.do_every_n_frames(5, 32)\n    def lidar_to_node_grid(self):\n        grid, offsets = self.point_cloud_extractor.transform_to_grid(self.lidar_grid)\n        for y, row in enumerate(grid):\n            for x, value in enumerate(row):\n                xx = (x - offsets[0]) * 2 + 1\n                yy = (y - offsets[1]) * 2 + 1\n                #print(value)\n                for direction in value:\n                    self.node_grid.load_straight_wall((xx, yy),  direction)\n\n    @utilities.do_every_n_frames(5, 32)\n    def process_floor(self, camera_images, total_point_cloud, robot_position, robot_rotation):\n        floor_image = self.camera_processor.get_floor_image(camera_images, robot_rotation)\n        final_image = np.zeros(floor_image.shape, dtype=np.uint8)\n\n        ranged_floor_image = cv.inRange(cv.cvtColor(floor_image, cv.COLOR_BGR2HSV), (0, 0, 100), (1, 1, 255))\n        #cv.imshow("floor_image", floor_image)\n\n        self.point_cloud_processor.center_point = (floor_image.shape[1] // 2, floor_image.shape[0] // 2)\n\n       \n        camera_point_cloud = self.point_cloud_processor.processPointCloudForCamera(total_point_cloud)\n        seen_points = self.point_cloud_processor.get_intermediate_points(camera_point_cloud)\n        #print(seen_points)\n\n\n        utilities.draw_poses(final_image, seen_points, back_image=floor_image, xx_yy_format=True)\n        \n        \n        floor_colors = self.floor_color_extractor.get_floor_colors(final_image, robot_position)\n\n        #robot_tile = utilities.divideLists(robot_position, [self.tile_size, self.tile_size])\n        robot_tile = [round((x + 0.03) / self.tile_size - 0.5) for x in robot_position]\n        robot_node = [t * 2 for t in robot_tile]\n       \n\n        \n        for floor_color in floor_colors:\n            tile = floor_color[0]\n            color = floor_color[1]\n            tile = utilities.multiplyLists(tile, [2, 2])\n            #tile.reverse()\n            tile = utilities.sumLists(tile, [1, 1])\n            tile = utilities.sumLists(tile, robot_node)\n            if SHOW_DEBUG:\n                print(self.node_grid.get_node(tile).node_type)\n            if self.node_grid.get_node(tile).tile_type != "start":\n                self.node_grid.get_node(tile).tile_type = color\n        \n        \n        #cv.imshow(\'final_image\', utilities.resize_image_to_fixed_size(final_image, (600, 600)))\n          \n        #self.lidar_grid.print_grid((600, 600))\n        #self.lidar_grid.print_bool((600, 600))\n    \n    def degs_to_orientation(self, degs):\n        """divides degrees in up, left, right or down"""\n        if utilities.normalizeDegs(180 - 45) < degs < 180:\n            return "up", "right"\n        if 180 <= degs < utilities.normalizeDegs(180 + 45):\n            return "up", "left"\n\n        elif utilities.normalizeDegs(360 - 45) < degs <= 360:\n            return "down", "left"\n        elif 0 <= degs < utilities.normalizeDegs(0 + 45):\n            return "down", "right" \n        \n        elif utilities.normalizeDegs(90 - 45) < degs < 90:\n            return "right", "down"\n        elif 90 <= degs < utilities.normalizeDegs(90 + 45):\n            return "right", "up"\n        \n        elif utilities.normalizeDegs(270 - 45) < degs < 270:\n            return "left", "up"\n        elif 270 <= degs < utilities.normalizeDegs(270 + 45):\n            return "left", "down"\n\n    \n    def load_wall_fixture(self, letter, image_angle):\n        \n        orient = self.degs_to_orientation(utilities.normalizeDegs(image_angle))\n        if SHOW_DEBUG:\n            print("images_angle:", image_angle)\n            print("orientation:", orient)   \n        dir1, dir2 = orient\n        direction = utilities.dir2list(dir1)\n        direction = utilities.multiplyLists(direction, [2, 2])\n        direction = utilities.sumLists(direction, utilities.dir2list(dir2))\n        wall_index = utilities.sumLists(self.robot_node, direction)\n        assert self.node_grid.get_node(wall_index).node_type == "wall"\n        self.node_grid.get_node(wall_index).fixtures_in_wall.append(letter)\n\n        \n\n    def load_fixture(self, letter, camera_angle, robot_rotation):\n        fixture = self.node_grid.get_node(self.robot_node).fixture\n        fixture.exists = True\n        fixture.type = letter\n\n        image_angle = utilities.normalizeDegs(camera_angle + robot_rotation)\n        fixture.detection_angle = image_angle\n    \n    def get_fixture(self):\n        return self.node_grid.get_node(self.robot_node).fixture\n\n    def set_robot_node(self, robot_position):\n        robot_vortex = [int((x + 0.03) // self.tile_size) for x in robot_position]\n        self.robot_vortex_center = [rt * self.tile_size for rt in robot_vortex]\n        robot_node = [int(t * 2) for t in robot_vortex]\n        self.robot_node = robot_node\n        for row in self.node_grid.grid:\n            for node in row:\n                node.is_robots_position = False\n\n        self.node_grid.get_node(self.robot_node).is_robots_position = True\n    \n    def block_front_vortex(self, robot_rotation):\n        orientation = utilities.dir2list(self.degs_to_orientation(robot_rotation)[0])\n\n        front_node = [r + (f * 2) for r, f in zip(self.robot_node, orientation)]\n        self.node_grid.get_node(front_node).status = "occupied"\n\n\n    def update(self, point_cloud=None, camera_images=None, robot_position=None, robot_rotation=None, current_time=None):\n        if robot_position is None or robot_rotation is None:\n            return\n        \n        robot_vortex = [int((x + 0.03) // self.tile_size) for x in robot_position]\n        robot_node = [int(t * 2) for t in robot_vortex]\n        robot_vortex_center = [rt * self.tile_size for rt in robot_vortex]\n        \n        distance = math.sqrt(sum([(x - y) ** 2 for x, y in zip(robot_vortex_center, robot_position)]))\n\n        if SHOW_DEBUG:\n            print("robot_vortex:", robot_vortex)\n\n        if self.robot_node is None:\n            self.set_robot_node(robot_position)\n        \n        if distance < 0.02:\n            for adj in ((1, 1), (-1, 1), (1, -1), (-1, -1)):\n                adj_node = utilities.sumLists(robot_node, adj)\n                self.node_grid.get_node(adj_node).explored = True\n        if distance < 0.02:\n            self.node_grid.get_node(robot_node).explored = True\n\n        if point_cloud is not None:\n            in_bounds_point_cloud, out_of_bounds_point_cloud = point_cloud\n            self.load_point_cloud(current_time, in_bounds_point_cloud, robot_position)\n            self.lidar_to_node_grid(current_time)\n\n        if point_cloud is not None and camera_images is not None and current_time is not None:\n            total_point_cloud = np.vstack((in_bounds_point_cloud, out_of_bounds_point_cloud))\n            self.process_floor(current_time, camera_images, total_point_cloud, robot_position, robot_rotation)\n            \n            if SHOW_DEBUG:\n                self.lidar_grid.print_grid((600, 600))\n                self.lidar_grid.print_bool((600, 600))  \n\n            #self.node_grid.print_grid()\n        \n        cv.waitKey(1) \n            \n    \n    def get_node_grid(self):\n        return self.node_grid #copy.deepcopy()\n    \n    def get_grid_for_bonus(self):\n        final_grid = []\n        for row in self.get_node_grid().grid:\n            final_row = []\n            for node in row:\n                final_row.append(node.get_representation())\n            final_grid.append(final_row)\n        return np.array(final_grid)\n')
    __stickytape_write_module('data_processing/camera_processor.py', b'import cv2 as cv\nimport numpy as np\nimport utilities\nimport imutils\n\nclass CameraProcessor:\n    def __init__(self, tile_resolution):\n        self.tile_resolution = tile_resolution # 100\n\n    def sharpen_image(self, image):\n        kernel = np.array([[-1,-1,-1], [-1,5,-1], [-1,-1,-1]])\n        return cv.filter2D(image, -1, kernel)\n\n    def upscale_image(image, scale):\n        return cv.resize(image, (0,0), fx=scale, fy=scale, interpolation=cv.INTER_CUBIC)\n\n    def flatten_image(self, image):\n        tiles_up = 2\n        tiles_down = 0\n        tiles_side = 1\n\n        minimum_x = self.tile_resolution * tiles_side\n        maximum_x = self.tile_resolution * (tiles_side + 1)\n        minimum_y = self.tile_resolution * (tiles_up)\n        maximum_y = self.tile_resolution * (tiles_up  + 1)  - 40\n\n        #robot1_points = np.array(([4, 17], [35, 17],  [31, 12],  [8, 12],), dtype=np.float32)\n        img_points = np.array(([5, 6],  [35, 6], [31, 3], [8, 3], ), dtype=np.float32)\n        final_points = np.array(([minimum_x, minimum_y],  [maximum_x, minimum_y], [maximum_x, maximum_y], [minimum_x, maximum_y],), dtype=np.float32)\n\n        ipm_matrix = cv.getPerspectiveTransform(img_points, final_points, solveMethod=cv.DECOMP_SVD)\n        \n        final_x = self.tile_resolution * ((tiles_side * 2) + 1)\n        final_y = self.tile_resolution * (tiles_up + 1 + tiles_down)\n        \n        final_y_modiff = round(final_y * 1)#0.95)\n\n        ipm = cv.warpPerspective(image, ipm_matrix, (final_x, final_y_modiff), flags=cv.INTER_NEAREST)\n        ipm = cv.resize(ipm, (final_x, final_y), interpolation=cv.INTER_CUBIC)\n\n        return ipm\n\n    def overlay_image_alpha(self, img, img_overlay, x, y, alpha_mask):\n        """Overlay `img_overlay` onto `img` at (x, y) and blend using `alpha_mask`.\n\n        `alpha_mask` must have same HxW as `img_overlay` and values in range [0, 1].\n        """\n        # Check that the dimensions of the images and the alpha mask match\n        if img_overlay.shape[:2] != alpha_mask.shape[:2]:\n            raise ValueError("The dimensions of the overlay and alpha mask must match")\n        \n        # Compute the region of the overlay image that will be visible in the output\n        y1, y2 = y, y + img_overlay.shape[0]\n        x1, x2 = x, x + img_overlay.shape[1]\n        y1, y2, x1, x2 = max(y1, 0), min(y2, img.shape[0]), max(x1, 0), min(x2, img.shape[1])\n        overlay_region = img_overlay[y1-y:y2-y, x1-x:x2-x]\n        alpha_mask = alpha_mask[y1-y:y2-y, x1-x:x2-x]\n        \n        # Blend the overlay image onto the input image using the alpha mask\n        alpha = alpha_mask[..., np.newaxis]\n        blended = (1.0 - alpha) * img[y1:y2, x1:x2] + alpha * overlay_region\n        \n        # Update the input image with the blended overlay\n        img[y1:y2, x1:x2] = blended\n        \n        return img\n\n    def join_camera_images(self, images, translations):\n        max_x = 0\n        max_y = 0\n\n        for translation in translations:\n            max_x = max(max_x, translation[1])\n            max_y = max(max_y, translation[0])\n\n        backround = np.zeros((max_x + images[0].shape[1], max_y + images[0].shape[0], 3), dtype=np.uint8)\n        \n        rot_imgs = []\n        for index, img in enumerate(images):\n            rot_imgs.append(np.rot90(img, index + 2, (0,1)))\n\n        for rot_img, translation in zip(rot_imgs, translations):\n            self.overlay_image_alpha(backround, rot_img[:,:,:3], translation[0], translation[1], rot_img[:,:,3] / 255)\n        \n        return backround.copy()\n\n    def rotate_image(self, image, robot_rotation):\n        rot = utilities.normalizeDegs(robot_rotation)\n        return imutils.rotate(image, rot)\n\n    def get_floor_image(self, images, robot_rotation):\n        flattened_images = []\n        for img in images:\n            img = np.rot90(img, 3, (0,1))\n            img = self.flatten_image(img)\n            img = np.flip(img, 0)\n            flattened_images.append(img)\n\n        x_red = 5\n        y_red = 2\n\n        translations = [[200 - y_red, 400 - x_red], [400 - x_red, 200 + y_red], [200 + y_red, 0 + x_red]]\n        camera_final_image = self.join_camera_images(flattened_images, translations)\n\n        return self.rotate_image(camera_final_image, robot_rotation - 90)\n\nif __name__ == "__main__":\n    pass')
    __stickytape_write_module('data_processing/data_extractor.py', b'import numpy as np\nimport cv2 as cv\nimport copy\n\nimport utilities\nfrom data_processing import camera_processor\nfrom data_processing import point_cloud_processor\n\nfrom flags import SHOW_DEBUG\n\nclass FloorColorExtractor:\n    def __init__(self, tile_resolution) -> None:\n        self.tile_resolution = tile_resolution\n        self.floor_color_ranges = {\n                    "normal":\n                        {   \n                            "range":   ((0, 0, 37), (0, 0, 192)), \n                            "threshold":0.2},\n\n                    "nothing":\n                        {\n                            "range":((100, 0, 0), (101, 1, 1)),\n                            "threshold":0.9},\n                    \n                    "checkpoint":\n                        {\n                            "range":((95, 0, 65), (128, 122, 198)),\n                            "threshold":0.2},\n                    "hole":\n                        {\n                            "range":((0, 0, 10), (0, 0, 30)),\n                            "threshold":0.2},\n                    \n                    "swamp":\n                        {\n                            "range":((19, 112, 32), (19, 141, 166)),\n                            "threshold":0.2},\n\n                    "connection1-2":\n                        {\n                            "range":((120, 182, 49), (120, 204, 232)),\n                            "threshold":0.2},\n\n                    "connection1-3":\n                        {\n                            "range":((132, 156, 36), (133, 192, 185)),\n                            "threshold":0.2},\n\n                    "connection2-3":\n                        {\n                            "range":((0, 182, 49), (0, 204, 232)),\n                            "threshold":0.2},\n                    }\n        self.final_image = np.zeros((700, 700, 3), np.uint8)\n        \n    def get_square_color(self, image, square_points):\n        square = image[square_points[0]:square_points[1], square_points[2]:square_points[3]]\n        square = cv.cvtColor(square, cv.COLOR_BGR2HSV)\n        if np.count_nonzero(square) == 0:\n            return "nothing"\n        color_counts = {}\n        for color_key, color_range in self.floor_color_ranges.items():\n            colour_count = np.count_nonzero(cv.inRange(square, color_range["range"][0], color_range["range"][1]))\n            if colour_count > color_range["threshold"] * square.shape[0] * square.shape[1]:\n                color_counts[color_key] = colour_count\n        \n        if len(color_counts) == 0:\n            return "nothing"\n        else:\n            return max(color_counts, key=color_counts.get)\n    \n    def get_sq_color(self, image, square_points):\n        square = image[square_points[0]:square_points[1], square_points[2]:square_points[3]]\n        # remove pixels with value 0, 0, 0\n        white_count = np.count_nonzero(cv.inRange(square, (180, 180, 180), (255, 255, 255)))\n        black_count = np.count_nonzero(cv.inRange(square, (20, 20, 20), (180, 180, 180)))\n\n        if white_count > black_count and white_count > square.shape[0] * square.shape[1] / 8:\n            return (255, 255, 255)\n        else:\n            return (100, 100, 100)\n\n    def get_floor_colors(self, floor_image, robot_position):\n\n        grid_offsets = [(((p + 0) % 0.06) / 0.06) * 50 for p in robot_position]\n        \n        grid_offsets = [int(o) for o in grid_offsets]\n\n        offsets = [((((p + 0.03) % 0.06) - 0.03) / 0.06) * 50 for p in robot_position]\n        \n        offsets = [int(o) for o in offsets]\n\n        \n        utilities.save_image(floor_image, "floor_image.png")\n\n        squares_grid = utilities.get_squares(floor_image, self.tile_resolution, offsets)\n\n        color_tiles = []\n        for row in squares_grid:\n            for square in row:\n                color_key = self.get_square_color(floor_image, square)\n                if color_key == "normal":\n                    color = (255, 255, 255)\n                elif color_key == "checkpoint":\n                    color = (100, 100, 100)\n                else:\n                    color = (0, 0, 0)\n                #if color != (0, 0, 0):\n                #cv.rectangle(self.final_image, [square[2], square[0]], [square[3], square[1]], color, -1)\n\n                tile = [square[2], square[0]]\n                tile = utilities.substractLists(tile, (350 - offsets[0], 350 - offsets[1]))\n                tile = utilities.divideLists(tile, [self.tile_resolution, self.tile_resolution])\n                tile = [int(t) for t in tile]\n                if color_key != "nothing":\n                    if SHOW_DEBUG:\n                        print(tile, color_key)\n                    color_tiles.append((tile, color_key))\n\n        if SHOW_DEBUG:\n            drawing_image = floor_image.copy() #self.final_image.copy()\n            utilities.draw_grid(drawing_image, self.tile_resolution, offset=grid_offsets)\n            cv.circle(drawing_image, (350 - offsets[0], 350 - offsets[1]), 10, (255, 0, 0), -1)\n            cv.imshow("final_floor_image", utilities.resize_image_to_fixed_size(drawing_image, (600, 600)))        \n        return color_tiles\n\n\n        \n        \n\nclass PointCloudExtarctor:\n    def __init__(self, resolution):\n        self.threshold = 8\n        self.resolution = resolution\n        self.straight_template = np.zeros((self.resolution + 1, self.resolution + 1), dtype=int)\n        self.straight_template[:][0:2] = 1\n        #self.straight_template[3:-3][0:2] = 2\n        self.straight_template[0][0:2] = 0\n        self.straight_template[-1][0:2] = 0\n\n        straight = [\n            [0, 1, 2, 2, 2, 1, 0],\n            [0, 1, 2, 2, 2, 1, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n                ]\n        \n        self.straight_template = np.array(straight)\n\n        curved = [\n            [0, 0, 0, 0, 0, 1, 0],\n            [0, 0, 0, 1, 1, 1, 0],\n            [0, 0, 3, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n                ]\n        \n        self.curved_template = np.array(curved)\n\n\n        self.templates = {}\n\n        for i, name in enumerate([("u",), ("l",), ("d",), ("r",)]):\n            self.templates[name] = np.rot90(self.straight_template, i)\n        \n        for i, name in enumerate([("u", "l"), ("d", "l"), ("d", "r"),  ("u", "r")]):\n            self.templates[name] = np.rot90(self.curved_template, i)\n\n    def get_tile_status(self, min_x, min_y, max_x, max_y, point_cloud):\n        counts = {name: 0 for name in self.templates}\n        square = point_cloud[min_x:max_x+1, min_y:max_y+1]\n        if square.shape != (self.resolution+1, self.resolution+1):\n            return []\n\n        non_zero_indices = np.where(square != 0)\n        for name, template in self.templates.items():\n            counts[name] = np.sum(template[non_zero_indices])\n\n        names = [name for name, count in counts.items() if count >= self.threshold]\n\n        return [i for sub in names for i in sub]\n\n    def transform_to_grid(self, point_cloud):\n        offsets = point_cloud.offsets\n        offsets = [o % self.resolution for o in offsets]\n        offsets.reverse()\n        grid = []\n        bool_array_copy = point_cloud.get_bool_array()\n        if SHOW_DEBUG:\n            bool_array_copy = bool_array_copy.astype(np.uint8) * 100\n        for x in range(offsets[0], bool_array_copy.shape[0] - self.resolution, self.resolution):\n            row = []\n            for y in range(offsets[1], bool_array_copy.shape[1] - self.resolution, self.resolution):\n                min_x = x\n                min_y = y\n                max_x = x + self.resolution\n                max_y = y + self.resolution\n                #print(min_x, min_y, max_x, max_y)\n\n                if SHOW_DEBUG:\n                    bool_array_copy = cv.rectangle(bool_array_copy, (min_y, min_x), (max_y, max_x), (255,), 1)\n                \n                val = self.get_tile_status(min_x, min_y, max_x, max_y, point_cloud.get_bool_array())\n                \n                row.append(list(val))\n            grid.append(row)\n        factor = 10\n\n        if SHOW_DEBUG:\n            cv.imshow("point_cloud_with_squares", utilities.resize_image_to_fixed_size(bool_array_copy, (600, 600)))\n        offsets = point_cloud.offsets\n        return grid, [o // self.resolution for o in offsets]')
    __stickytape_write_module('data_processing/point_cloud_processor.py', b"import numpy as np\n\nfrom bresenham import bresenham\nfrom skimage.draw import line\nfrom scipy.spatial.distance import cdist\n\nclass PointCloudProcessor:\n    def __init__(self, center_point, map_scale):\n        self.map_scale = map_scale # 850\n        self.center_point = [center_point, center_point] #350\n\n    def processPointCloud(self, pc, robotPos):\n        return [[pcv + rpv for pcv, rpv in zip(pos, robotPos)] for pos in pc]\n\n    def processPointCloudForCamera(self, pc):\n        if len(pc) == 0:\n            return np.empty((0, 2), dtype=int)\n        return np.array([[int(p * self.map_scale) + c for c, p in zip(self.center_point,  pos)] for pos in pc], dtype=int)\n\n\n    def get_intermediate_points(self, point_cloud):\n        max_points_per_line = int(np.max(cdist(point_cloud, [self.center_point]))) + 1  # calculate max possible points per line\n        seen_x = np.empty(len(point_cloud) * max_points_per_line, dtype=int)\n        seen_y = np.empty(len(point_cloud) * max_points_per_line, dtype=int)\n        index = 0\n        for point in point_cloud:\n            xx, yy = line(self.center_point[0], self.center_point[1], point[0], point[1]) \n            n_points = len(xx)\n            seen_x[index:index+n_points] = xx\n            seen_y[index:index+n_points] = yy\n            index += n_points\n        return seen_x[:index], seen_y[:index]\n\n\nif __name__ == '__main__':\n    pass\n\n")
    __stickytape_write_module('data_structures/lidar_persistent_grid.py', b'import numpy as np\nimport cv2 as cv\n\nimport utilities\n\nfrom data_structures import resizable_pixel_grid\n\nfrom flags import SHOW_DEBUG\n\nclass LidarGrid(resizable_pixel_grid.Grid):\n    def __init__(self, input_resolution, resolution, threshold=0):\n        self.input_res = input_resolution\n        self.res = resolution\n        self.multiplier = self.res / self.input_res\n        self.frame = 0\n        \n        self.shape = (self.res, self.res)\n        super().__init__(self.shape, self.res)\n        self.threshold = 100\n        self.delete_threshold = 4\n\n    def get_bool_array(self):\n        return self.grid > self.threshold\n    \n    def clean_up(self):\n        if SHOW_DEBUG:\n            print("Cleaning up lidar grid")\n        self.grid = self.grid * (self.grid > self.delete_threshold).astype(int)\n\n    \n    def sum_detection(self, point):\n        point = [round(p * self.multiplier) for p in point]\n        self.sum_to_point(point, 1)\n    \n    def print_bool(self, max_size=(600, 600)):\n        grid1 = utilities.resize_image_to_fixed_size(self.get_bool_array(), max_size)\n        cv.imshow("bool_grid", grid1 * 255)\n        cv.waitKey(1)\n    \n    def update(self, point_cloud):\n        self.clean_up()\n        for point in point_cloud:\n            self.sum_detection(point)\n        self.frame += 1\n\n        \n    ')
    __stickytape_write_module('data_structures/resizable_pixel_grid.py', b'import numpy as np\nimport cv2 as cv\nimport copy\nimport utilities\n\nclass Grid:\n    def __init__(self, initial_shape, res=100):\n        self.offsets = [initial_shape[0] // 2, initial_shape[1] // 2]\n        self.resolution = res\n        self.shape = initial_shape\n        self.grid = np.zeros(self.shape, dtype=int)\n\n        self.value_divider = 1023 / 255\n        self.value_limit = 1023\n\n    def expand_grid_to_point(self, point):\n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n\n        if y + 1 > self.shape[0]:\n            self.add_end_row(y - self.shape[0] +1)\n        if x + 1 > self.shape[1]:\n            self.add_end_column(x - self.shape[1] +1)\n        if y < 0:\n            self.add_begining_row(-y)\n        if x < 0:\n            self.add_begining_column(-x)\n    \n    \n    def add_point(self, point, value=255):\n        self.expand_grid_to_point(point)\n        \n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n    \n        self.grid[y, x] = value\n    \n    def sum_to_point(self, point, value):\n        self.expand_grid_to_point(point)\n        \n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n    \n        self.grid[y, x] = min(self.grid[y, x] + value, self.value_limit)\n    \n    def get_point(self, point):\n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n        return self.grid[y, x]\n     \n    def add_end_row(self, size):\n        self.shape = (self.shape[0]+ size, self.shape[1] )\n        self.grid = np.vstack((self.grid, np.zeros((size, self.shape[1]), dtype=int)))\n    \n    def add_begining_row(self, size):\n        self.offsets[1] += size\n        self.shape = (self.shape[0]+ size, self.shape[1] )\n        self.grid = np.vstack((np.zeros((size, self.shape[1]), dtype=int), self.grid))\n    \n    def add_end_column(self, size):\n        self.shape = (self.shape[0], self.shape[1] + size)\n        self.grid = np.hstack((self.grid, np.zeros((self.shape[0], size), dtype=int)))\n\n    def add_begining_column(self, size):\n        self.offsets[0] += size\n        self.shape = (self.shape[0], self.shape[1] + size)\n        self.grid = np.hstack((np.zeros((self.shape[0], size), dtype=int), self.grid))\n\n    def print_grid(self, max_size=(2000, 1000)):\n        grid1 = copy.deepcopy(self.grid)\n       \n        grid1 = grid1 // self.value_divider\n\n        grid1 = utilities.resize_image_to_fixed_size(grid1, max_size)\n\n        cv.imshow("grid", grid1.astype(np.uint8))\n        cv.waitKey(1)\n\nif __name__ == "__main__":\n    my_grid = Grid((5, 5))\n\n    my_grid.add_point((2, 2))\n    print(my_grid.offsets)\n\n    my_grid.print_grid()\n\n    my_grid.add_point((-5, -10))\n    print(my_grid.offsets)\n\n    my_grid.print_grid()')
    __stickytape_write_module('data_structures/expandable_node_grid.py', b'import numpy as np\nimport cv2 as cv\nimport copy\nimport utilities\n\n"""\nRequirements:\n\n1 = Node type (tile, vortex, wall)\n2 = Status (ocupied, not_occupied, undefined)\n3 = Tile type (only if tile: undefined, start, normal, connection1-2, connection1-3, connection2-3, swamp, hole)\n\nundefined = no conozco el tipo de casilla\n"""\nclass Fixture:\n    def __init__(self, exists=False, reported=False, type="N") -> None:\n        self.exists = exists\n        self.reported = reported\n        self.type = type\n        self.detection_angle = None\n\nclass Node:\n    def __init__(self, node_type:str, status:str="undefined", tile_type:str="undefined", curved:int=0, explored:bool=False, is_robots_position:bool=False):\n        self.node_type = node_type\n        self.status = status\n        self.tile_type = tile_type if node_type == "tile" else "undefined"\n        self.explored = explored\n        self.is_robots_position = is_robots_position\n        self.fixture = Fixture()\n        self.fixtures_in_wall = []\n        self.is_start = False\n        self.is_curved = False\n\n        self.mark1 = 0\n        self.mark2 = 0\n        \n        self.valid_node_type = ("tile", \n                                "vortex",\n                                "wall") #tuple with valid values for the variables of the node\n        \n        self.valid_status = (   "occupied",\n                                "undefined",\n                                "not_occupied") #same tuple\n\n        self.valid_tile_types = ("undefined",\n                                "normal",\n                                "start",\n                                "connection1-2",\n                                "connection1-3", \n                                "connection2-3", \n                                "swamp", \n                                "hole",\n                                "checkpoint") #same tuple\n\n        self.tile_type_to_string = {\n            "undefined": "0",\n            "normal": "0",\n            "checkpoint": "4",\n            "start": "5",\n            "connection1-2": "6",\n            "connection1-3": "7",\n            "connection2-3": "8",\n            "swamp": "3",\n            "hole": "2"\n        }\n       \n\n\n    def get_representation(self) -> str:\n        if self.node_type == "tile":\n            return self.tile_type_to_string[self.tile_type]\n\n        elif self.node_type == "vortex":\n            return str(int(self.status == "occupied" and not self.is_curved))\n        \n        elif self.node_type == "wall":\n            if len(self.fixtures_in_wall) > 0:\n                return str("".join(self.fixtures_in_wall))\n            return str(int(self.status == "occupied"))\n        \n        else:\n            return "0"\n\n    # Returns a visual representation of the node in ASCII \n    def get_string(self):\n\n        if self.mark1:\n            return "\\033[1;36;36m\xe2\x96\x88\xe2\x96\x88" + "\\033[0m"\n\n        if self.status == "undefined":\n            if not(self.node_type == "tile" and self.tile_type != "undefined"):    \n                return "??"\n        \n\n        if self.status == "occupied":\n            if self.node_type == "vortex" and self.explored:\n                return "\\033[1;31;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n\n            if self.node_type == "wall" and len(self.fixtures_in_wall) > 0:\n                return f"\\033[1;35;40m{self.fixtures_in_wall[0]*2}" + "\\033[0m"\n            \n            return "\\033[1;30;40m\xe2\x96\x88\xe2\x96\x88" + "\\033[0m"\n        \n        \n        #elif self.is_robots_position:\n        #    return "\\033[1;32;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n        \n        elif self.node_type == "wall":\n            """\n            if self.status == "not_occupied":\n                return "\\033[1;37;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            """\n            return "\\033[1;30;47m||"+ "\\033[0m"\n        elif self.node_type == "vortex": #vertice\n            """\n            if self.status == "not_occupied":\n                return "\\033[1;37;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            """\n            if self.explored:\n                return "\\033[1;32;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n\n            return "\\033[1;30;47m<>"+ "\\033[0m"\n        \n        elif self.node_type == "tile":\n\n            if self.explored:\n                if self.tile_type == "start":\n                    return "\\033[1;32;47m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "hole":\n                    return "\\033[0m  "+ "\\033[0m"\n                if self.tile_type == "swamp":\n                    return "\\033[1;33;40m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "checkpoint":\n                    return "\\033[0m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "connection1-3":\n                    return "\\033[1;35;47m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "connection1-2":\n                    return "\\033[1;34;47m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "connection2-3":\n                    return "\\033[1;31;47m\xe2\x96\x88E"+ "\\033[0m"\n                if self.tile_type == "normal":\n                    return "\\033[1;37;47m\xe2\x96\x88E"+ "\\033[0m"\n            \n            if self.tile_type == "start":\n                return "\\033[1;32;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "hole":\n                return "\\033[0m  "+ "\\033[0m"\n            if self.tile_type == "swamp":\n                return "\\033[1;33;40m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "checkpoint":\n                return "\\033[0m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "connection1-3":\n                return "\\033[1;35;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "connection1-2":\n                return "\\033[1;34;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "connection2-3":\n                return "\\033[1;31;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n            if self.tile_type == "normal":\n                return "\\033[1;37;47m\xe2\x96\x88\xe2\x96\x88"+ "\\033[0m"\n\n            return "\\033[1;30;47m??"+ "\\033[0m"\n            \n        \n        \n    def __str__(self) -> str:\n        return self.get_string()\n\n    def __repr__(self) -> str:\n        return self.get_string()\n\nclass Grid:\n    def __init__(self, initial_shape):\n        self.offsets = [initial_shape[0] // 2, initial_shape[1] // 2]\n        self.shape = initial_shape\n        self.grid = np.empty(initial_shape, dtype=object)\n        self.fill_nodes(self.grid)\n        self.fill_node_types()\n    \n    def get_node_type(self, point):\n        x_div = point[0] % 2 == 0\n        y_div = point[1] % 2 == 0\n        if x_div and y_div:\n            return "vortex"\n        elif x_div and not y_div:\n            return "wall"\n        elif not x_div and y_div:\n            return "wall"\n        elif not x_div and not y_div:\n            return "tile"\n    \n    def get_type_node_poses(self, node_type):\n        grid = []\n        for y, row in enumerate(self.grid):\n            new_row = []\n            for x, node in enumerate(row):\n                if node.node_type == node_type:\n                    new_row.append((x, y))\n            grid.append(row)\n        return grid\n    \n    def fill_nodes(self, grid):\n        for i in range(grid.shape[0]):\n            for j in range(grid.shape[1]):\n                grid[i, j] = Node("undefined")\n\n    def fill_node_types(self, x_min=0, y_min=0, x_max=None, y_max=None):\n        if x_max is None:\n            x_max = self.shape[1]\n        if y_max is None:\n            y_max = self.shape[0]\n        \n        for y in range(y_min, y_max):\n            for x in range(x_min, x_max):\n                self.grid[y, x].node_type = self.get_node_type((x + self.offsets[0], y + self.offsets[1]))\n                self.grid[y, x].status = "not_occupied"\n\n    def add_end_row(self, size):\n        self.shape = (self.shape[0]+ size, self.shape[1] )\n        row = np.empty((size, self.shape[1]), dtype=object)\n        self.fill_nodes(row)\n        self.grid = np.vstack((self.grid, row))\n        self.fill_node_types(y_min=self.shape[0]-size)\n    \n    def add_begining_row(self, size):\n        self.offsets[1] += size\n        self.shape = (self.shape[0]+ size, self.shape[1] )\n        row = np.empty((size, self.shape[1]), dtype=object)\n        self.fill_nodes(row)\n        self.grid = np.vstack((row, self.grid))\n        self.fill_node_types(y_max=size)\n    \n    def add_end_column(self, size):\n        self.shape = (self.shape[0], self.shape[1] + size)\n        column = np.empty((self.shape[0], size), dtype=object)\n        self.fill_nodes(column)\n        self.grid = np.hstack((self.grid, column))\n        self.fill_node_types(x_min=self.shape[1]-size)\n\n    def add_begining_column(self, size):\n        self.offsets[0] += size\n        self.shape = (self.shape[0], self.shape[1] + size)\n        column = np.empty((self.shape[0], size), dtype=object)\n        self.fill_nodes(column)\n        self.grid = np.hstack((column, self.grid))\n        self.fill_node_types(x_max=size)\n\n    def expand_grid_to_point(self, point):\n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n\n        if y + 1 > self.shape[0]:\n            self.add_end_row(y - self.shape[0] +1)\n        if x + 1 > self.shape[1]:\n            self.add_end_column(x - self.shape[1] +1)\n        if y < 0:\n            self.add_begining_row(-y)\n        if x < 0:\n            self.add_begining_column(-x)\n    \n    def get_node(self, point, expand=True, phantom=False):\n        if expand:\n            self.expand_grid_to_point(point)\n        elif not self.is_in_grid(point):\n            if phantom:\n                return Node(self.get_node_type(point))\n            return None\n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n        return self.grid[y, x]\n    \n    def is_in_grid(self, point):\n        x, y = point\n        x, y = x + self.offsets[0], y + self.offsets[1]\n        return 0 <= x < self.grid.shape[1] and 0 <= y < self.grid.shape[0]\n\n    def fill_verticies_around_wall(self, wall_node):\n        assert self.get_node(wall_node).node_type == "wall"\n        for a in ([-1, 0], [1, 0], [0, -1], [0, 1]):\n            x, y = wall_node\n            x += a[1]\n            y += a[0]\n            node = self.get_node((x, y))\n            if node.node_type == "vortex":\n                node.status = "occupied"\n\n    def load_straight_wall(self, tile, direction):\n        assert self.get_node(tile).node_type == "tile"\n        list_direction = utilities.dir2list(direction)\n        wall = [t + d for t, d in zip(tile, list_direction)]\n\n        self.get_node((wall[0], wall[1])).status = "occupied"\n        self.fill_verticies_around_wall((wall[0], wall[1]))\n\n\n    def print_grid(self):\n        for row in self.grid:\n            for node in row:\n                print(node, end="")\n            print()\n        print()\n    \nif __name__ == "__main__":\n    grid = Grid((10, 10))\n    \n    grid.get_node((0, 0)).status = "occupied"\n    grid.get_node((-5, -5)).status = "occupied"\n    grid.get_node((-5, 4)).status = "occupied"\n    grid.get_node((4, -5)).status = "occupied"\n    grid.get_node((4, 4)).status = "occupied"\n    grid.print_grid()\n\n    """\n    grid.add_end_row(2)\n    grid.print_grid()\n    grid.add_begining_row(2)\n    grid.print_grid()\n    grid.add_end_column(2)\n    grid.print_grid()\n    grid.add_begining_column(2)\n    grid.print_grid()\n    """\n\n     \n    \n')
    __stickytape_write_module('algorithms/expandable_node_grid/bfs.py', b'from algorithms.expandable_node_grid.traversable import is_traversable\n\ndef is_bfs_addable(grid, index):\n    node = grid.get_node(index, expand=False, phantom=True)\n    if node.node_type == "vortex":\n        for adj in ((1, 1), (-1, 1), (1, -1), (-1, -1)):\n            adjacent = [index[0] + adj[0], index[1] + adj[1]]\n            if not grid.get_node(adjacent, expand=False, phantom=True).explored:\n                return True\n        return False\n    else:\n        return False\n\n# Breath First Search algorithm\n# Returns the tiles in order and with the distance of each one\ndef bfs(grid, start, limit="undefined"):\n    visited = []\n    queue = []\n    found = []\n    start = [start[0], start[1], 0]\n    visited.append(start)\n    queue.append(start)\n    while queue:\n        if len(found) > 100:\n            break\n        coords = queue.pop(0)\n        y = coords[1]\n        x = coords[0]\n        dist = coords[2]\n        if limit != "undefined":\n            if dist > limit:\n                break\n        \n        if is_bfs_addable(grid, coords[:2]):\n            found.append(coords)\n\n        for newPosition in ((0, 1), (0, -1), (-1, 0), (1, 0)):\n            neighbour = [x + newPosition[0] * 2, y + newPosition[1] * 2, dist + 1]\n            inList = False\n            for node in visited:\n                if node[0] == neighbour[0] and node[1] == neighbour[1]:\n                    inList = True\n                    break\n            if inList:\n                continue\n\n            # Make sure walkable terrain\n            if is_traversable(grid, neighbour[:2]):\n                visited.append(neighbour)\n                queue.append(neighbour)\n\n    return found')
    __stickytape_write_module('algorithms/expandable_node_grid/traversable.py', b'def is_traversable(grid, index):\n    node = grid.get_node(index, expand=False, phantom=True)\n    if node.node_type == "vortex":\n        if node.explored:\n            return True\n        if node.status == "occupied":\n            return False\n        traversable = True\n        for adjacentIndex in ((-1, 1), (1, -1), (1, 1), (-1, -1), (0, 1), (0, -1), (1, 0), (-1, 0)):\n            adjacent = grid.get_node((index[0] + adjacentIndex[0], index[1] + adjacentIndex[1]), expand=False, phantom=True)\n            \n            if adjacent.node_type == "tile":\n                if adjacent.tile_type == "hole" or adjacent.status == "occupied":\n                    traversable = False\n                    \n            elif adjacent.node_type == "wall":\n                if adjacent.status == "occupied":\n                    traversable = False\n            else:\n                raise ValueError((f"invalid instance: {node.node_type}"))\n        return traversable\n    else:\n        raise ValueError((f"invalid instance: {node.node_type}"))')
    __stickytape_write_module('agents/closest_position_agent/closest_position_agent.py', b'from agents.agent import Agent\nimport utilities\n\nfrom algorithms.expandable_node_grid.a_star import a_star\nfrom algorithms.expandable_node_grid.bfs import bfs\nfrom algorithms.expandable_node_grid.traversable import is_traversable\n\nfrom flags import SHOW_DEBUG\n\nclass ClosestPositionAgent(Agent):\n    def __init__(self):\n        super().__init__(["up", "down", "left", "right"])\n        self.current_robot_node = self.previous_robot_node = None\n        self.best_node = [None, None]\n        self.a_star_path = []\n        self.a_star_index = 0\n\n    def find_robot_node(self, grid):\n        for y, row in enumerate(grid.grid):\n            for x, node in enumerate(row):\n                if node.is_robots_position:\n                    return [x - grid.offsets[0], y - grid.offsets[1]]\n    \n    def find_start_node(self, grid):\n        for y, row in enumerate(grid.grid):\n            for x, node in enumerate(row):\n                if node.is_start:\n                    return [x - grid.offsets[0], y - grid.offsets[1]]\n                \n\n\n    def get_best_node(self, possible_nodes):\n        if len(possible_nodes) > 0:\n            best_node = possible_nodes[0]\n            if best_node[:2] == list(self.current_robot_node):\n                best_node = possible_nodes[1]\n\n            orientation = utilities.substractLists(self.current_robot_node, self.previous_robot_node)\n            forward_node = utilities.sumLists(self.current_robot_node, orientation)\n            for node in possible_nodes[:10]:\n                if list(node[:2]) == list(forward_node):\n                    best_node = forward_node\n\n        else:\n            best_node = self.current_robot_node\n        #return possibleNodes[-1][:2]\n        return best_node[:2]\n    \n    def check_path(self, grid):\n        for position in self.a_star_path:\n            if not is_traversable(grid, position):\n                return False\n        return True\n    \n    def predict(self, grid):\n        robot_node = self.find_robot_node(grid)\n        \n        if robot_node != self.current_robot_node:\n            self.previous_robot_node = self.current_robot_node\n            self.current_robot_node = robot_node\n        if self.previous_robot_node is None:\n            self.previous_robot_node = self.current_robot_node\n\n        if len(self.a_star_path) <= self.a_star_index or not self.check_path(grid):\n            direction = utilities.substractLists(self.current_robot_node, self.previous_robot_node)\n            if is_traversable(grid, self.current_robot_node):\n                possible_nodes = bfs(grid, self.current_robot_node, 100)\n            else:\n                possible_nodes = bfs(grid, self.previous_robot_node, 100)\n\n            #print("Possible nodes:", possible_nodes)\n            if len(possible_nodes):\n                self.best_node = self.get_best_node(possible_nodes)\n            else:\n                self.best_node = self.find_start_node(grid)\n\n            best_path = a_star(grid, self.current_robot_node, self.best_node)\n\n            if len(best_path) > 1:\n                self.a_star_path = best_path[1:]\n                self.a_star_index = 0\n\n        if SHOW_DEBUG:\n            for node in self.a_star_path:\n                grid.get_node(node).mark1 = True\n            grid.print_grid()\n\n        move = utilities.substractLists(self.a_star_path[self.a_star_index], self.current_robot_node)\n        move = utilities.multiplyLists(move, [0.5, 0.5])\n\n        if self.current_robot_node == list(self.a_star_path[self.a_star_index]):\n            self.a_star_index += 1\n\n        if SHOW_DEBUG:\n            print("Best node:", self.best_node)\n            print("Start node:", self.current_robot_node)\n            print("AStar path: ", self.a_star_path)\n\n\n        return [int(m) for m in move]\n        ')
    __stickytape_write_module('agents/agent.py', b'import random\n\nclass Agent:\n    def __init__(self, possible_actions=[]) -> None:\n        self.possible_actions = possible_actions\n\n    def predict(self, state: list) -> list:\n        raise NotImplementedError\n\n    def get_action(self, state: list) -> str:\n        return self.predict(state)\n\n\nclass RandomAgent(Agent):\n    def __init__(self, possible_actions=[]) -> None:\n        super().__init__(possible_actions)\n\n    def predict(self, state: list) -> str:\n        return random.choice(self.possible_actions)')
    __stickytape_write_module('algorithms/expandable_node_grid/a_star.py', b'from algorithms.expandable_node_grid.traversable import is_traversable\n\n# aStarNode class for A* pathfinding (Not to be confused with the node grid)\nclass aStarNode():\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n# Returns a list of tuples as a path from the given start to the given end in the given maze\ndef a_star(grid, start, end):\n    #assert is_traversable(grid, start)\n    if not is_traversable(grid, start):\n        print("WARNING: Start position is not traversable")\n\n    assert is_traversable(grid, end)\n\n    # Create start and end node\n    startNode = aStarNode(None, (start[0], start[1]))\n    startNode.g = startNode.h = startNode.f = 0\n    endNode = aStarNode(None, (end[0], end[1]))\n    endNode.g = endNode.h = endNode.f = 0\n    # Initialize open and closed list\n    openList = []\n    closedList = []\n    # Add the start node\n    openList.append(startNode)\n    # Loop until end\n    while len(openList) > 0:\n        # Get the current node\n        currentNode = openList[0]\n        currentIndex = 0\n        for index, item in enumerate(openList):\n            if item.f < currentNode.f:\n                currentNode = item\n                currentIndex = index\n        # Pop current off open list, add to closed list\n        openList.pop(currentIndex)\n        closedList.append(currentNode)\n        # If found the goal\n        if currentNode == endNode:\n            path = []\n            current = currentNode\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]  # Return reversed path\n        # Generate children\n        children = []\n        for newPosition in ((0, 1), (0, -1), (-1, 0), (1, 0)):  # Adjacent squares\n            # Get node position\n            nodePosition = (currentNode.position[0] + (newPosition[0] * 2), currentNode.position[1] + (newPosition[1] * 2))\n            # Make sure walkable terrain\n            if not is_traversable(grid, nodePosition):\n                continue\n            # Create new node\n            newNode = aStarNode(currentNode, nodePosition)\n            # Append\n            children.append(newNode)\n        # Loop through children\n        for child in children:\n            continueLoop = False\n            # Child is on the closed list\n            for closedChild in closedList:\n                if child == closedChild:\n                    continueLoop = True\n                    break\n            # Create the f, g, and h values\n            child.g = currentNode.g + 1\n            child.h = ((child.position[0] - endNode.position[0]) ** 2) + (\n                        (child.position[1] - endNode.position[1]) ** 2)\n            child.f = child.g + child.h\n            # Child is already in the open list\n            for openNode in openList:\n                if child == openNode and child.g > openNode.g:\n                    continueLoop = True\n                    break\n            if continueLoop:\n                continue\n            # Add the child to the open list\n            openList.append(child)')
    __stickytape_write_module('agents/go_back_agent/go_back_agent.py', b'from agents.agent import Agent\nimport utilities\n\nfrom algorithms.expandable_node_grid.a_star import a_star\n\nfrom flags import SHOW_DEBUG\n\nclass GoBackAgent(Agent):\n    def __init__(self):\n        super().__init__(["up", "down", "left", "right"])\n        self.current_robot_node = self.previous_robot_node = None\n        self.best_node = [None, None]\n        self.a_star_path = []\n        self.a_star_index = 0\n\n    def find_robot_node(self, grid):\n        for y, row in enumerate(grid.grid):\n            for x, node in enumerate(row):\n                if node.is_robots_position:\n                    return [x - grid.offsets[0], y - grid.offsets[1]]\n    \n    def find_start_node(self, grid):\n        for y, row in enumerate(grid.grid):\n            for x, node in enumerate(row):\n                if node.is_start:\n                    return [x - grid.offsets[0], y - grid.offsets[1]]\n    \n    def predict(self, grid):\n        robot_node = self.find_robot_node(grid)\n        \n        if robot_node != self.current_robot_node:\n            self.previous_robot_node = self.current_robot_node\n            self.current_robot_node = robot_node\n        if self.previous_robot_node is None:\n            self.previous_robot_node = self.current_robot_node\n        \n        start_node = self.find_start_node(grid)\n        if start_node == self.current_robot_node:\n            return None\n\n        if len(self.a_star_path) <= self.a_star_index:\n            best_path = a_star(grid, self.current_robot_node, start_node)\n\n            if len(best_path) > 1:\n                self.a_star_path = best_path[1:]\n                self.a_star_index = 0\n\n        if SHOW_DEBUG:\n            for node in self.a_star_path:\n                grid.get_node(node).mark1 = True\n            grid.print_grid()\n\n        move = utilities.substractLists(self.a_star_path[self.a_star_index], self.current_robot_node)\n        move = utilities.multiplyLists(move, [0.5, 0.5])\n\n        if self.current_robot_node == list(self.a_star_path[self.a_star_index]):\n            self.a_star_index += 1\n\n        if SHOW_DEBUG:\n            print("Best node:", self.best_node)\n            print("Start node:", self.current_robot_node)\n            print("AStar path: ", self.a_star_path)\n\n\n        return [int(m) for m in move]')
    import cv2 as cv
    import numpy as np
    import time
    import copy
    import math
    
    from data_processing import fixture_detection
    import utilities, state_machines, robot, mapping
    from algorithms.expandable_node_grid.bfs import bfs
    
    from agents.closest_position_agent.closest_position_agent import ClosestPositionAgent
    from agents.go_back_agent.go_back_agent import GoBackAgent
    
    from flags import SHOW_DEBUG
    
    window_n = 0
    
    
    # World constants
    TIME_STEP = 32
    TILE_SIZE = 0.06
    TIME_IN_ROUND = 8 * 60
    
    
    # Components
    #Robot
    robot = robot.RobotLayer(TIME_STEP)
    
    # Stores, changes and compare states
    stateManager = state_machines.StateManager("init")
    
    # Sequence manager
    # Resets flags that need to be in a certain value when changing sequence, for example when changing state
    def resetSequenceFlags():
        robot.delay_first_time = True
    seq = state_machines.SequenceManager(resetFunction=resetSequenceFlags)
    
    # Mapper
    mapper = mapping.Mapper(TILE_SIZE)
    
    closest_position_agent = ClosestPositionAgent()
    go_back_agent = GoBackAgent()
    
    
    # Variables
    do_mapping = False
    do_victim_reporting = False
    
    
    # Functions
    # Sequential functions used frequently
    seqPrint = seq.makeSimpleEvent(print)
    seqDelaySec = seq.makeComplexEvent(robot.delay_sec)
    seqMoveWheels = seq.makeSimpleEvent(robot.move_wheels)
    seqRotateToDegs = seq.makeComplexEvent(robot.rotate_to_degs)
    seqMoveToCoords = seq.makeComplexEvent(robot.move_to_coords)
    seqResetSequenceFlags = seq.makeSimpleEvent(resetSequenceFlags)
    
    # Calculates offsets in the robot position, in case it doesn't start perfectly centerd
    def calibratePositionOffsets():
        actualTile = [robot.position[0] // TILE_SIZE, robot.position[1] // TILE_SIZE]
        robot.position_offsets = [
            round((actualTile[0] * TILE_SIZE) - robot.position[0]) + TILE_SIZE // 2,
            round((actualTile[1] * TILE_SIZE) - robot.position[1]) + TILE_SIZE // 2]
        robot.position_offsets = [robot.position_offsets[0] % TILE_SIZE, robot.position_offsets[1] % TILE_SIZE]
        print("positionOffsets: ", robot.position_offsets)
    
    def seqCalibrateRobotRotation():
        # Calibrates the robot rotation using the gps
        if seq.simpleEvent():
            robot.auto_decide_rotation = False
        seqMoveWheels(-1, -1)
        seqDelaySec(0.1)
        if seq.simpleEvent(): robot.rotation_sensor = "gps"
        seqMoveWheels(1, 1)
        seqDelaySec(0.1)
        if seq.simpleEvent(): robot.rotation_sensor= "gyro"
        seqDelaySec(0.1)
        seqMoveWheels(0, 0)
        seqMoveWheels(-1, -1)
        seqDelaySec(0.1)
        seqMoveWheels(0, 0)
        if seq.simpleEvent():
            robot.auto_decide_rotation = True
    
    initial_position = robot.position
    
    def seqMoveToRelativeCoords(x, y):
        global initial_position
        if seq.simpleEvent():
            initial_position = [round(p / TILE_SIZE) * TILE_SIZE for p in robot.position]
        return seqMoveToCoords((initial_position[0] + x, initial_position[1] + y))
    
    def seqMoveToRelativeTile(x, y):
        node = mapper.robot_node
        tile = [node[0] // 2 + x, node[1] // 2 + y]
        return seqMoveToCoords(correct_position([tile[0] * TILE_SIZE, tile[1] * TILE_SIZE]))
    
    def is_complete(grid, robot_node):
            possible_nodes = bfs(grid, robot_node, 500)
            if len(possible_nodes) == 0:
                return True
            return False
    
    def robot_fits(robot_node, show_debug=False):
        global window_n
        robot_diameter_in_nodes = int(math.ceil(robot.diameter * mapper.lidar_grid.multiplier))
        robot_radious_in_nodes = robot_diameter_in_nodes // 2
        min_x = int(robot_node[0] - robot_radious_in_nodes + 1)
        max_x = int(robot_node[0] + robot_radious_in_nodes+ 0)
        min_y = int(robot_node[1] - robot_radious_in_nodes + 1)
        max_y = int(robot_node[1] + robot_radious_in_nodes + 0)
        min_x = max(min_x, 0)
        max_x = min(max_x, mapper.lidar_grid.grid.shape[0])
        min_y = max(min_y, 0)
        max_y = min(max_y, mapper.lidar_grid.grid.shape[1])
        #print("square: ", min_x, max_x, min_y, max_y)
        square = mapper.lidar_grid.get_bool_array()[min_y:max_y, min_x:max_x]
    
        square1 = copy.deepcopy(square).astype(np.uint8)
        square1 = square1 * 255
    
        if show_debug:
            try:
                cv.imshow(f"square{window_n}", square1.astype(np.uint8))
                print(f"Showing square{window_n}")
            except:
                print(f"Error showing square{window_n}")
        window_n += 1
    
        return np.count_nonzero(square)
    
    def correct_position(robot_position):
        if SHOW_DEBUG:
            print("INITIAL POSITION: ", robot_position)
        max_correction = 2
        exageration_factor = 1
        robot_node = [round(p * mapper.lidar_grid.multiplier) for p in robot_position]
        robot_node = [robot_node[0] + mapper.lidar_grid.offsets[0], robot_node[1] + mapper.lidar_grid.offsets[1]]
    
        best_node = {"pos":robot_node, "dist":0, "amount":robot_fits(robot_node, show_debug=SHOW_DEBUG)}
    
        orientation = [abs(r - c) for r, c in zip(mapper.robot_vortex_center, robot_position)]
    
        if orientation[1] > orientation[0]:
            y = 0
            for x in range(-max_correction, max_correction + 1):
                possible_pos = [robot_node[0] + (x * exageration_factor), robot_node[1] + (y * exageration_factor)]
                distance = math.sqrt(abs(x) ** (2) + abs(y) ** 2)
                amount_of_nodes = robot_fits(possible_pos, show_debug=SHOW_DEBUG)
                
                if amount_of_nodes < best_node["amount"]:
                    best_node["pos"] = [p - 0.0 for p in possible_pos]
                    best_node["dist"] = distance
                    best_node["amount"] = amount_of_nodes
                elif amount_of_nodes == best_node["amount"]:
                    if distance < best_node["dist"]:
                        best_node["pos"] = [p - 0.0 for p in possible_pos]
                        best_node["dist"] = distance
                        best_node["amount"] = amount_of_nodes
    
        elif orientation[0] > orientation[1]:
            x = 0
            for y in range(-max_correction, max_correction + 1):
                possible_pos = [robot_node[0] + (x * exageration_factor), robot_node[1] + (y * exageration_factor)]
                distance = math.sqrt(abs(x) ** (2) + abs(y) ** 2)
                amount_of_nodes = robot_fits(possible_pos)
    
                #print("varying in y")
    
                if amount_of_nodes < best_node["amount"]:
                    best_node["pos"] = [p - 0.0 for p in possible_pos]
                    best_node["dist"] = distance
                    best_node["amount"] = amount_of_nodes
                elif amount_of_nodes == best_node["amount"]:
                    if distance < best_node["dist"]:
                        best_node["pos"] = [p - 0.0 for p in possible_pos]
                        best_node["dist"] = distance
                        best_node["amount"] = amount_of_nodes
    
        final_pos = [(p - o) / mapper.lidar_grid.multiplier for p, o in zip(best_node["pos"], mapper.lidar_grid.offsets)]
        #print("CORRECTED POSITION: ", final_pos)
        return final_pos
    
    # Each timeStep
    while robot.do_loop():
        # Updates robot position and rotation, sensor positions, etc.
        robot.update()
        
        # Loads data to mapping
        if do_mapping:
            lidar_point_cloud = robot.get_detection_point_cloud()
            images = robot.get_camera_images()
            #utilities.save_image(images[1], "camera_image_center.png")
            mapper.update(lidar_point_cloud, images, robot.position, robot.rotation, current_time=robot.time)
    
        else:
            mapper.update(robot_position=robot.position, robot_rotation=robot.rotation, current_time=robot.time)
        
        if do_mapping:
            images = robot.get_camera_images()
            for index, image in enumerate(images):
                angle = (index - 1) * 90
    
                rot_img = np.rot90(image, -1)
    
                victims = fixture_detection.find_victims(rot_img)
                if len(victims) > 0:
                    letter = fixture_detection.classify_fixture(victims[0])
                    if letter is not None:
                        mapper.load_fixture(letter, angle, robot.rotation)
                        
                    break
        
        #fixture_detection.tune_filter(robot.get_camera_images()[1])
    
        # Updates state machine
        if not stateManager.checkState("init"):
            if SHOW_DEBUG:
                print("stuck_counter: ", robot.stuck_counter)
            if robot.is_stuck():
                if SHOW_DEBUG:
                    print("FRONT BLOCKED")
                mapper.block_front_vortex(robot.rotation)
                if not stateManager.checkState("stuck"):
                    seq.resetSequence()
                    stateManager.changeState("stuck")
        
        
            if mapper.get_fixture().exists and not mapper.get_fixture().reported and do_victim_reporting:
                if not stateManager.checkState("report_victim"):
                    seq.resetSequence()
                    stateManager.changeState("report_victim")
    
            elif robot.comunicator.remainingTime < 30:
                if not stateManager.checkState("go_back") and not stateManager.checkState("end"):
                    seq.resetSequence()
                    stateManager.changeState("go_back")
    
        if SHOW_DEBUG:
            print("state: ", stateManager.state)
    
        # Runs once when starting the game
        if stateManager.checkState("init"):
            seq.startSequence()
            seqDelaySec(0.5)
            # Calculates offsets in the robot position, in case it doesn't start perfectly centerd
            seq.simpleEvent(calibratePositionOffsets)
            # Informs the mapping components of the starting position of the robot
            seq.simpleEvent(mapper.register_start, robot.position)
            # Calibrates the rotation of the robot using the gps
            seqCalibrateRobotRotation()
            # Starts mapping walls
            if seq.simpleEvent():
                do_mapping = True
                do_victim_reporting = True
            if seq.simpleEvent():
                #do_mapping = False
                #do_victim_reporting = False
                pass
            # Changes state and resets the sequence
            seq.simpleEvent(stateManager.changeState, "explore")
            seq.seqResetSequence()
    
        elif stateManager.checkState("stop"):
            seq.startSequence()
            seqMoveWheels(0, 0)
    
        # Explores and maps the maze
        elif stateManager.checkState("explore"):
            seq.startSequence()
    
            grid = mapper.get_node_grid()
            move = closest_position_agent.get_action(grid)
            if SHOW_DEBUG:
                print("move: ", move)
            node = mapper.robot_node
    
            if seqMoveToRelativeTile(move[0], move[1]):
                mapper.set_robot_node(robot.position)
                if mapper.node_grid.get_node(mapper.robot_node).is_start:
                    if is_complete(mapper.node_grid, mapper.robot_node):
                        seq.resetSequence()
                        stateManager.changeState("end")
    
            seq.seqResetSequence()
    
            if SHOW_DEBUG:
                print("rotation:", robot.rotation)
                print("position:", robot.position)
    
        # Reports a victim
        elif stateManager.checkState("report_victim"):
            seq.startSequence()
            seqMoveWheels(0, 0)
            if seq.simpleEvent() and SHOW_DEBUG:
                print("STOPPED")
            seqDelaySec(1.2)
            if seq.simpleEvent():
                fixture = mapper.get_fixture()
                robot.comunicator.sendVictim(robot.position, fixture.type)
                fixture.reported = True
                mapper.load_wall_fixture(letter, fixture.detection_angle)
            seq.simpleEvent(stateManager.changeState, "explore")
            seq.seqResetSequence()
        
        elif stateManager.checkState("teleported"):
            seq.startSequence()
            # parar mapping
            do_mapping = False
            seqCalibrateRobotRotation()
            # Changes state and resets the sequence
            seq.simpleEvent(stateManager.changeState, "explore")
            seq.seqResetSequence()
        
        elif stateManager.checkState("end"):
            robot.comunicator.sendMap(mapper.get_grid_for_bonus())
            robot.comunicator.sendEndOfPlay()
        
        elif stateManager.checkState("stuck"):
            if SHOW_DEBUG:
                print("IS IN STUCK")
            seq.startSequence()
            if seq.simpleEvent():
                robot.auto_decide_rotation = False
                robot.rotation_sensor = "gyro"
            seqMoveWheels(-0.5, -0.5)
            seqDelaySec(0.2)
            seqMoveWheels(0, 0)
            if seq.simpleEvent():
                robot.auto_decide_rotation = True
            seq.simpleEvent(stateManager.changeState, "explore")
            seq.seqResetSequence()
        
        elif stateManager.checkState("go_back"):
            if SHOW_DEBUG:
                print("IS IN GO BACK")
            seq.startSequence()
            grid = mapper.get_node_grid()
            move = go_back_agent.get_action(grid)
            if SHOW_DEBUG:
                print("move: ", move)
            if move is None:
                stateManager.changeState("end")
                seq.seqResetSequence()
            else:
                node = mapper.robot_node
    
                if seqMoveToRelativeTile(move[0], move[1]):
                    mapper.set_robot_node(robot.position)
                seq.seqResetSequence()
    
                if SHOW_DEBUG:
                    print("rotation:", robot.rotation)
                    print("position:", robot.position)
    
        if SHOW_DEBUG:
            print("robot time:", robot.comunicator.remainingTime)
        robot.comunicator.update()
        window_n = 0
            
    
    
    